public boolean isDateExpired(String input, Date expiration) throws ParseException { DateFormat dateFormat = new SimpleDateFormat ("dd/MM/yyyy"); Date date = dateFormat.parse(input); return date.after(expiration); }
String string = "January 2, 2010"; DateFormat format = new SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH); Date date = format.parse(string); System.out.println(date);
public static String toString(java.util.Date date) { if (date == null) { return null; } SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return format.format(date); }
DateFormat df = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss"); Date today = Calendar.getInstance().getTime(); String reportDate = df.format(today); System.out.println("Report Date: " + reportDate);
SimpleDateFormat dateParser = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss"); Date date = dateParser.parse(dateTime); SimpleDateFormat dateFormatter = new SimpleDateFormat("MM/dd/yyyy"); System.out.println(dateFormatter.format(date));
public static String getCurrentTimeAsString() { SimpleDateFormat format = new SimpleDateFormat(DATE_FORMAT); return format.format(new Date()); } }
private static String clientDateString() { TimeZone tz = TimeZone.getTimeZone("UTC"); DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'"); df.setTimeZone(tz); return df.format(new Date()); }
private static void printJobStatusMessages(List<JobStatusMessage> jobs) { SimpleDateFormat dateFormat = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss"); Comparator<JobStatusMessage> startTimeComparator = (o1, o2) -> (int) (o1.getStartTime() - o2.getStartTime()); Comparator<Map.Entry<JobStatus, List<JobStatusMessage>>> statusComparator = (o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getKey().toString(), o2.getKey().toString()); Map<JobStatus, List<JobStatusMessage>> jobsByState = jobs.stream().collect(Collectors.groupingBy(JobStatusMessage::getJobState)); jobsByState.entrySet().stream() .sorted(statusComparator) .map(Map.Entry::getValue).flatMap(List::stream).sorted(startTimeComparator) .forEachOrdered(job -> System.out.println(dateFormat.format(new Date(job.getStartTime())) + " : " + job.getJobId() + " : " + job.getJobName() + " (" + job.getJobState() + ")")); }
SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'"); try { Date date = new Date(); String datetime = dateFormat.format(date); System.out.println("Current Date Time : " + datetime); } catch (ParseException e) { e.printStackTrace(); }
Calendar cal = new GregorianCalendar(); SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy"); dateFormat.setTimeZone(cal.getTimeZone()); System.out.println(dateFormat.format(cal.getTime()));
String newstring = new SimpleDateFormat("yyyy-MM-dd").format(date); System.out.println(newstring); 
String dateStr = "04/05/2010"; SimpleDateFormat curFormater = new SimpleDateFormat("dd/MM/yyyy"); Date dateObj = curFormater.parse(dateStr); SimpleDateFormat postFormater = new SimpleDateFormat("MMMM dd, yyyy"); String newDateStr = postFormater.format(dateObj);
@Override public Object decode(Object jv) throws IOException { if (jv instanceof String) { try { return new SimpleDateFormat(DATE_FORMAT).parse((String) jv); } catch (ParseException e) { throw new IllegalArgumentException(e.getMessage(), e); } } if (jv instanceof Number) { return new Date(((Number) jv).longValue()); } return (Date) null; } };
@Test public void testCalendarTimezoneRespected() { final Calendar cal = Calendar.getInstance(timeZone); final SimpleDateFormat sdf = new SimpleDateFormat(PATTERN); sdf.setTimeZone(timeZone); final String expectedValue = sdf.format(cal.getTime()); final String actualValue = FastDateFormat.getInstance(PATTERN, this.timeZone).format(cal); assertEquals(expectedValue, actualValue); }
String oldstring = "2011-01-18 00:00:00.0"; Date date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S").parse(oldstring);
public void write(JSONSerializer serializer, Object object, BeanContext context) throws IOException { SerializeWriter out = serializer.out; String format = context.getFormat(); Calendar calendar = (Calendar) object; if (format.equals("unixtime")) { long seconds = calendar.getTimeInMillis() / 1000L; out.writeInt((int) seconds); return; } DateFormat dateFormat = new SimpleDateFormat(format); if (dateFormat == null) { dateFormat = new SimpleDateFormat(JSON.DEFFAULT_DATE_FORMAT, serializer.locale); dateFormat.setTimeZone(serializer.timeZone); } String text = dateFormat.format(calendar.getTime()); out.writeString(text); }
Calendar cal = Calendar.getInstance(); SimpleDateFormat sdf = new SimpleDateFormat("EEE MMM dd HH:mm:ss z yyyy", Locale.ENGLISH); cal.setTime(sdf.parse("Mon Mar 14 16:02:37 GMT 2011"));
public class Foo { private static final ThreadLocal<SimpleDateFormat> formatter = new ThreadLocal<SimpleDateFormat>(){ @Override protected SimpleDateFormat initialValue() { return new SimpleDateFormat("yyyyMMdd HHmm"); } }; public String formatIt(Date date) { return formatter.get().format(date); } }
SimpleDateFormat dateFormatGmt = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss"); dateFormatGmt.setTimeZone(TimeZone.getTimeZone("GMT")); SimpleDateFormat dateFormatLocal = new SimpleDateFormat("yyyy-MMM-dd HH:mm:ss"); return dateFormatLocal.parse( dateFormatGmt.format(new Date()) );
String dt = "2008-01-01"; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Calendar c = Calendar.getInstance(); c.setTime(sdf.parse(dt)); c.add(Calendar.DATE, 1);  dt = sdf.format(c.getTime());  