public static void printMap(Map mp) { Iterator it = mp.entrySet().iterator(); while (it.hasNext()) { Map.Entry pair = (Map.Entry)it.next(); System.out.println(pair.getKey() + " = " + pair.getValue()); it.remove(); } }
for (Map.Entry<String, Object> entry : map.entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); }
public Challenge(String scheme, Map<String, String> authParams) { if (scheme == null) throw new NullPointerException("scheme == null"); if (authParams == null) throw new NullPointerException("authParams == null"); this.scheme = scheme; Map<String, String> newAuthParams = new LinkedHashMap<>(); for (Entry<String, String> authParam : authParams.entrySet()) { String key = (authParam.getKey() == null) ? null : authParam.getKey().toLowerCase(US); newAuthParams.put(key, authParam.getValue()); } this.authParams = unmodifiableMap(newAuthParams); }
private void innerUpdateEndOffsets(final Map<TopicPartition, Long> newOffsets, final boolean replace) { for (final Map.Entry<TopicPartition, Long> entry : newOffsets.entrySet()) { List<Long> offsets = endOffsets.get(entry.getKey()); if (replace || offsets == null) { offsets = new ArrayList<>(); } offsets.add(entry.getValue()); endOffsets.put(entry.getKey(), offsets); } }
public Map<String, Double> getOperatorHashCollisionsAverages() { return operatorHashCollisionsStats.entrySet().stream().collect(toMap( Map.Entry::getKey, entry -> entry.getValue().getWeightedHashCollisions() / operatorInputStats.get(entry.getKey()).getInputPositions())); }
private Map<String, List<LazyHeaderFactory>> copyHeaders() { Map<String, List<LazyHeaderFactory>> result = new HashMap<>(headers.size()); for (Map.Entry<String, List<LazyHeaderFactory>> entry : headers.entrySet()) { @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops") List<LazyHeaderFactory> valueCopy = new ArrayList<>(entry.getValue()); result.put(entry.getKey(), valueCopy); } return result; }
static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException { stream.writeInt(map.size()); for (Map.Entry<K, V> entry : map.entrySet()) { stream.writeObject(entry.getKey()); stream.writeObject(entry.getValue()); } }
private static <T, M extends Map<T, String>> M populate(M map, Entry<T, String>[] entries) { for (Entry<T, String> entry : entries) { map.put(entry.getKey(), entry.getValue()); } return map; }
public static boolean mapEquals(Map<?, ?> map1, Map<?, ?> map2) { if (map1 == null && map2 == null) { return true; } if (map1 == null || map2 == null) { return false; } if (map1.size() != map2.size()) { return false; } for (Map.Entry<?, ?> entry : map1.entrySet()) { Object key = entry.getKey(); Object value1 = entry.getValue(); Object value2 = map2.get(key); if (!objectEquals(value1, value2)) { return false; } } return true; }
@Override public Iterable<Entry<K, Collection<V>>> order(List<Entry<K, Collection<V>>> insertionOrder) { Map<K, Collection<V>> map = new HashMap<>(); List<Entry<K, V>> builder = new ArrayList<>(); for (Entry<K, Collection<V>> entry : insertionOrder) { for (V v : entry.getValue()) { builder.add(mapEntry(entry.getKey(), v)); } map.put(entry.getKey(), entry.getValue()); } Iterable<Entry<K, V>> ordered = multimapGenerator.order(builder); LinkedHashMap<K, Collection<V>> orderedMap = new LinkedHashMap<>(); for (Entry<K, V> entry : ordered) { orderedMap.put(entry.getKey(), map.get(entry.getKey())); } return orderedMap.entrySet(); }
@Override public Entry<K, V> next() { if (!valueItr.hasNext()) { Entry<K, ? extends ImmutableCollection<V>> entry = asMapItr.next(); currentKey = entry.getKey(); valueItr = entry.getValue().iterator(); } return Maps.immutableEntry(currentKey, valueItr.next()); } };
public void testOrderedAsMapEntries() { TreeMultimap<String, Integer> multimap = createPopulate(); Iterator<Entry<String, Collection<Integer>>> iterator = multimap.asMap().entrySet().iterator(); Entry<String, Collection<Integer>> entry = iterator.next(); assertEquals(null, entry.getKey()); assertThat(entry.getValue()).containsExactly(7, 3, 1); entry = iterator.next(); assertEquals("tree", entry.getKey()); assertThat(entry.getValue()).containsExactly(null, 0); entry = iterator.next(); assertEquals("google", entry.getKey()); assertThat(entry.getValue()).containsExactly(6, 2); }
@Override protected void expectContents(Collection<Entry<K, V>> expected) { super.expectContents(expected); for (Entry<K, V> entry : expected) { assertEquals( "Wrong value for key " + entry.getKey(), entry.getValue(), getMap().get(entry.getKey())); } }
@Override public String toString() { Iterator<Map.Entry<String, Object>> entries = entrySet().iterator(); StringBuilder sb = new StringBuilder("{"); while (entries.hasNext()) { Map.Entry<String, Object> entry = entries.next(); sb.append(entry.getKey()); sb.append('='); sb.append(valueToString(entry.getValue())); sb.append(entries.hasNext() ? ", " : ""); } sb.append("}"); return sb.toString(); }
private void putAll(Iterable<Entry<K, V>> entries) { Map<K, V> map = new LinkedHashMap<>(); for (Entry<K, V> entry : entries) { map.put(entry.getKey(), entry.getValue()); } getMap().putAll(map); }
static <T> StringBuilder allSequenceFrequency(Map<Integer, List<T>> its) { StringBuilder b = new StringBuilder(); for (Map.Entry<Integer, List<T>> e : its.entrySet()) { if (b.length() > 0) { b.append(", "); } b.append(e.getKey()).append("={"); b.append(sequenceFrequency(e.getValue())); b.append("}"); } return b; } static <T> StringBuilder sequenceFrequency(Iterable<T> it) {
@CollectionSize.Require(absent = ZERO) @MapFeature.Require(SUPPORTS_REMOVE) public void testEntriesRemainValidAfterRemove() { Iterator<Entry<K, V>> iterator = multimap().entries().iterator(); Entry<K, V> entry = iterator.next(); K key = entry.getKey(); V value = entry.getValue(); multimap().removeAll(key); assertEquals(key, entry.getKey()); assertEquals(value, entry.getValue()); } }
Map map = new HashMap(); Iterator entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry entry = (Map.Entry) entries.next(); Integer key = (Integer)entry.getKey(); Integer value = (Integer)entry.getValue(); System.out.println("Key = " + key + ", Value = " + value); }
static <K, V> void putAllImpl(Map<K, V> self, Map<? extends K, ? extends V> map) { for (Entry<? extends K, ? extends V> entry : map.entrySet()) { self.put(entry.getKey(), entry.getValue()); } }
private void checkAllDataSources() { Map<String, DataSource> dataSourceMap = selector.getDataSourceMap(); for (Map.Entry<String, DataSource> e : dataSourceMap.entrySet()) { if (!(e.getValue() instanceof DruidDataSource)) { continue; } boolean flag = check(e.getKey(), (DruidDataSource) e.getValue()); if (flag) { errorCounts.put(e.getKey(), 0); } else { if (!errorCounts.containsKey(e.getKey())) { errorCounts.put(e.getKey(), 0); } int count = errorCounts.get(e.getKey()); errorCounts.put(e.getKey(), count + 1); } } }
private static <T, M extends Map<T, String>> M populate(M map, Entry<T, String>[] entries) { for (Entry<T, String> entry : entries) { map.put(entry.getKey(), entry.getValue()); } return map; }
static <K, V> void putAllImpl(Map<K, V> self, Map<? extends K, ? extends V> map) { for (Entry<? extends K, ? extends V> entry : map.entrySet()) { self.put(entry.getKey(), entry.getValue()); } }
private Map<C, V> getOrCreate(R rowKey) { Map<C, V> map = backingMap.get(rowKey); if (map == null) { map = factory.get(); backingMap.put(rowKey, map); } return map; }
void addContributor(String owner, String repo, String name, int contributions) { Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner); if (repoContributors == null) { repoContributors = new LinkedHashMap<>(); ownerRepoContributors.put(owner, repoContributors); } List<Contributor> contributors = repoContributors.get(repo); if (contributors == null) { contributors = new ArrayList<>(); repoContributors.put(repo, contributors); } contributors.add(new Contributor(name, contributions)); } }
private byte[] encodeHeaderKey(String input, boolean escape) { String inputToUse = (escape ? escape(input) : input); if (this.headerKeyAccessCache.containsKey(inputToUse)) { return this.headerKeyAccessCache.get(inputToUse); } synchronized (this.headerKeyUpdateCache) { byte[] bytes = this.headerKeyUpdateCache.get(inputToUse); if (bytes == null) { bytes = inputToUse.getBytes(StandardCharsets.UTF_8); this.headerKeyAccessCache.put(inputToUse, bytes); this.headerKeyUpdateCache.put(inputToUse, bytes); } return bytes; } }
private void modifyEnvironment(Map<String, String> buildEnv) { for (Map.Entry<String, String> entry : env.entrySet()) { if ("PATH".equals(entry.getKey())) { buildEnv.put("PATH", buildEnv.get("PATH") + File.pathSeparatorChar + env.get("PATH")); } else { buildEnv.put(entry.getKey(), entry.getValue()); } } }
@Override public void set(K key, @Nullable V value) { List<V> values = new LinkedList<>(); values.add(value); this.map.put(key, values); }
private void innerUpdateEndOffsets(final Map<TopicPartition, Long> newOffsets, final boolean replace) { for (final Map.Entry<TopicPartition, Long> entry : newOffsets.entrySet()) { List<Long> offsets = endOffsets.get(entry.getKey()); if (replace || offsets == null) { offsets = new ArrayList<>(); } offsets.add(entry.getValue()); endOffsets.put(entry.getKey(), offsets); } }
public void addOptionArg(String optionName, @Nullable String optionValue) { if (!this.optionArgs.containsKey(optionName)) { this.optionArgs.put(optionName, new ArrayList<>()); } if (optionValue != null) { this.optionArgs.get(optionName).add(optionValue); } }
private void createConnectionsMaxReauthMsMap(Map<String, ?> configs) { for (String mechanism : jaasContexts.keySet()) { String prefix = ListenerName.saslMechanismPrefix(mechanism); Long connectionsMaxReauthMs = (Long) configs.get(prefix + BrokerSecurityConfigs.CONNECTIONS_MAX_REAUTH_MS); if (connectionsMaxReauthMs == null) connectionsMaxReauthMs = (Long) configs.get(BrokerSecurityConfigs.CONNECTIONS_MAX_REAUTH_MS); if (connectionsMaxReauthMs != null) connectionsMaxReauthMsByMechanism.put(mechanism, connectionsMaxReauthMs); } }
@Override public Iterable<Entry<E>> order(List<Entry<E>> insertionOrder) { Map<E, Entry<E>> map = new LinkedHashMap<>(); for (Entry<E> entry : insertionOrder) { map.put(entry.getElement(), entry); } Set<E> seen = new HashSet<>(); List<Entry<E>> order = new ArrayList<>(); for (E e : gen.order(new ArrayList<E>(map.keySet()))) { if (seen.add(e)) { order.add(map.get(e)); } } return order; } }
@Override public boolean setInitParameter(String name, String value) { Assert.notNull(name, "Parameter name must not be null"); if (this.initParameters.containsKey(name)) { return false; } this.initParameters.put(name, value); return true; }
private void checkAllDataSources() { Map<String, DataSource> dataSourceMap = selector.getDataSourceMap(); for (Map.Entry<String, DataSource> e : dataSourceMap.entrySet()) { if (!(e.getValue() instanceof DruidDataSource)) { continue; } boolean flag = check(e.getKey(), (DruidDataSource) e.getValue()); if (flag) { errorCounts.put(e.getKey(), 0); } else { if (!errorCounts.containsKey(e.getKey())) { errorCounts.put(e.getKey(), 0); } int count = errorCounts.get(e.getKey()); errorCounts.put(e.getKey(), count + 1); } } }
private void updateBindingContext(BindingContext context, ServerWebExchange exchange) { Map<String, Object> model = context.getModel().asMap(); model.keySet().stream() .filter(name -> isBindingCandidate(name, model.get(name))) .filter(name -> !model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) .forEach(name -> { WebExchangeDataBinder binder = context.createDataBinder(exchange, model.get(name), name); model.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); }); }
private void putAll(Iterable<Entry<K, V>> entries) { Map<K, V> map = new LinkedHashMap<>(); for (Entry<K, V> entry : entries) { map.put(entry.getKey(), entry.getValue()); } getMap().putAll(map); }
@SuppressWarnings("unchecked") public void addAfterComment(String comment) { if (attributes == null) { attributes = new HashMap<String, Object>(1); } List<String> comments = (List<String>) attributes.get("format.after_comment"); if (comments == null) { comments = new ArrayList<String>(2); attributes.put("format.after_comment", comments); } comments.add(comment); }
void putSanitizeName(RType rType, String sanitizeName, String rawName) { HashMap<String, String> sanitizeNameMap; if (!sanitizeTypeMap.containsKey(rType)) { sanitizeNameMap = new HashMap<>(); sanitizeTypeMap.put(rType, sanitizeNameMap); } else { sanitizeNameMap = sanitizeTypeMap.get(rType); } if (!sanitizeNameMap.containsKey(sanitizeName)) { sanitizeNameMap.put(sanitizeName, rawName); } }
@Override public BenchmarkResultHook addResults(Map<String, Long> results) { requireNonNull(results, "results is null"); for (Entry<String, Long> entry : results.entrySet()) { Long currentSum = resultsSum.get(entry.getKey()); if (currentSum == null) { currentSum = 0L; } resultsSum.put(entry.getKey(), currentSum + entry.getValue()); } resultsCount++; return this; }
public void putAll(Map<String, Object> map) { for (Map.Entry<String, Object> entry : map.entrySet()) { mMap.put(entry.getKey(), entry.getValue()); } }
@Override public void set(K key, @Nullable V value) { List<V> values = new LinkedList<>(); values.add(value); this.targetMap.put(key, values); }
private void mappingWordsLength(List<String> wordsList) { Map<Integer, Set<String>> mapping = new HashMap<>(); for (String word : wordsList) { mapping.computeIfAbsent(word.length(), HashSet::new).add(word); } List<Integer> lengths = new LinkedList<>(mapping.keySet()); Collections.sort(lengths); lengths.forEach(n -> System.out.println(mapping.get(n).size() + " words with " + n + " chars")); }
@Override public List<InetAddress> lookup(String hostname) throws UnknownHostException { requestedHosts.add(hostname); List<InetAddress> result = hostAddresses.get(hostname); if (result != null) return result; throw new UnknownHostException(); }
ServiceMethod<?> loadServiceMethod(Method method) { ServiceMethod<?> result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); } } return result; }
@Override public Object lookup(String name) throws NamingException { Object object = this.jndiObjects.get(name); if (object == null) { throw new NamingException("Unexpected JNDI name '" + name + "': expecting " + this.jndiObjects.keySet()); } return object; }
void addContributor(String owner, String repo, String name, int contributions) { Map<String, List<Contributor>> repoContributors = ownerRepoContributors.get(owner); if (repoContributors == null) { repoContributors = new LinkedHashMap<>(); ownerRepoContributors.put(owner, repoContributors); } List<Contributor> contributors = repoContributors.get(repo); if (contributors == null) { contributors = new ArrayList<>(); repoContributors.put(repo, contributors); } contributors.add(new Contributor(name, contributions)); } }
static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) throws ProtocolException { List<String> values = javaResponseHeaders.get(null); if (values == null || values.size() == 0) { throw new ProtocolException( "CacheResponse is missing a \'null\' header containing the status line. Headers=" + javaResponseHeaders); } return values.get(0); }
private byte[] encodeHeaderKey(String input, boolean escape) { String inputToUse = (escape ? escape(input) : input); if (this.headerKeyAccessCache.containsKey(inputToUse)) { return this.headerKeyAccessCache.get(inputToUse); } synchronized (this.headerKeyUpdateCache) { byte[] bytes = this.headerKeyUpdateCache.get(inputToUse); if (bytes == null) { bytes = inputToUse.getBytes(StandardCharsets.UTF_8); this.headerKeyAccessCache.put(inputToUse, bytes); this.headerKeyUpdateCache.put(inputToUse, bytes); } return bytes; } }
private void createConnectionsMaxReauthMsMap(Map<String, ?> configs) { for (String mechanism : jaasContexts.keySet()) { String prefix = ListenerName.saslMechanismPrefix(mechanism); Long connectionsMaxReauthMs = (Long) configs.get(prefix + BrokerSecurityConfigs.CONNECTIONS_MAX_REAUTH_MS); if (connectionsMaxReauthMs == null) connectionsMaxReauthMs = (Long) configs.get(BrokerSecurityConfigs.CONNECTIONS_MAX_REAUTH_MS); if (connectionsMaxReauthMs != null) connectionsMaxReauthMsByMechanism.put(mechanism, connectionsMaxReauthMs); } }
private List<ContentGroup> getContentsForCharacter(FontCharacter character) { if (contentsForCharacter.containsKey(character)) { return contentsForCharacter.get(character); } List<ShapeGroup> shapes = character.getShapes(); int size = shapes.size(); List<ContentGroup> contents = new ArrayList<>(size); for (int i = 0; i < size; i++) { ShapeGroup sg = shapes.get(i); contents.add(new ContentGroup(lottieDrawable, this, sg)); } contentsForCharacter.put(character, contents); return contents; }
private List<AbstractProject> get(Map<AbstractProject, List<DependencyGroup>> map, AbstractProject src, boolean up) { List<DependencyGroup> v = map.get(src); if(v==null) return Collections.emptyList(); List<AbstractProject> result = new ArrayList<AbstractProject>(v.size()); for (DependencyGroup d : v) result.add(up ? d.getUpstreamProject() : d.getDownstreamProject()); return result; }
public static String getVerticalFormattedOutput(List<Map<String, Object>> content, String[] titleFields) { List<String[]> printContents = new ArrayList<String[]>(); int maxCol = content.size() > MAX_COL ? MAX_COL : content.size(); for (String titleField : titleFields) { String[] row = new String[maxCol + 1]; row[0] = titleField; for (int j = 0; j < maxCol; j++) { Map<String, Object> sqlStat = content.get(j); Object value = sqlStat.get(titleField); row[j + 1] = handleAndConvert(value, titleField); } printContents.add(row); } return TableFormatter.format(printContents); }
public int addCategory(String category) { Integer id = categoryId.get(category); if (id == null) { id = categoryId.size(); categoryId.put(category, id); assert idCategory.size() == id; idCategory.add(category); } return id; }
public void addOptionArg(String optionName, @Nullable String optionValue) { if (!this.optionArgs.containsKey(optionName)) { this.optionArgs.put(optionName, new ArrayList<>()); } if (optionValue != null) { this.optionArgs.get(optionName).add(optionValue); } }
@Override public Iterable<Entry<E>> order(List<Entry<E>> insertionOrder) { Map<E, Entry<E>> map = new LinkedHashMap<>(); for (Entry<E> entry : insertionOrder) { map.put(entry.getElement(), entry); } Set<E> seen = new HashSet<>(); List<Entry<E>> order = new ArrayList<>(); for (E e : gen.order(new ArrayList<E>(map.keySet()))) { if (seen.add(e)) { order.add(map.get(e)); } } return order; } }
@Test public void testGenericTypeNestingListOfMapOfInteger() throws Exception { List<Map<String, String>> list = new LinkedList<>(); Map<String, String> map = new HashMap<>(); map.put("testKey", "5"); list.add(map); NestedGenericCollectionBean gb = new NestedGenericCollectionBean(); BeanWrapper bw = new BeanWrapperImpl(gb); bw.setPropertyValue("listOfMapOfInteger", list); Object obj = gb.getListOfMapOfInteger().get(0).get("testKey"); assertTrue(obj instanceof Integer); assertEquals(5, ((Integer) obj).intValue()); }
@Implementation(minSdk = JELLY_BEAN_MR2) protected Account[] getAccountsByTypeForPackage(String type, String packageName) { List<Account> result = new ArrayList<>(); Account[] accountsByType = getAccountsByType(type); for (Account account : accountsByType) { if (packageVisibileAccounts.containsKey(account) && packageVisibileAccounts.get(account).contains(packageName)) { result.add(account); } } return result.toArray(new Account[result.size()]); }
@Nullable private Object getNativeHeaderValue(Message<?> message, String name) { Map<String, List<String>> nativeHeaders = getNativeHeaders(message); if (name.startsWith("nativeHeaders.")) { name = name.substring("nativeHeaders.".length()); } if (nativeHeaders == null || !nativeHeaders.containsKey(name)) { return null; } List<?> nativeHeaderValues = nativeHeaders.get(name); return (nativeHeaderValues.size() == 1 ? nativeHeaderValues.get(0) : nativeHeaderValues); }
@Test public void testGenericListOfMaps() throws MalformedURLException { GenericBean<String> gb = new GenericBean<>(); List<Map<Integer, Long>> list = new LinkedList<>(); list.add(new HashMap<>()); gb.setListOfMaps(list); BeanWrapper bw = new BeanWrapperImpl(gb); bw.setPropertyValue("listOfMaps[0][10]", new Long(5)); assertEquals(new Long(5), bw.getPropertyValue("listOfMaps[0][10]")); assertEquals(new Long(5), gb.getListOfMaps().get(0).get(10)); }
private void updateBindingContext(BindingContext context, ServerWebExchange exchange) { Map<String, Object> model = context.getModel().asMap(); model.keySet().stream() .filter(name -> isBindingCandidate(name, model.get(name))) .filter(name -> !model.containsKey(BindingResult.MODEL_KEY_PREFIX + name)) .forEach(name -> { WebExchangeDataBinder binder = context.createDataBinder(exchange, model.get(name), name); model.put(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); }); }
@Override protected List<Entry> buildFeedEntries(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) { List<Entry> entries = new ArrayList<>(); for (String name : model.keySet()) { Entry entry = new Entry(); entry.setTitle(name); Content content = new Content(); content.setValue((String) model.get(name)); entry.setSummary(content); entries.add(entry); } return entries; } }