@Override public Short apply(String input) { return Short.parseShort(input); } };
public MutableShort(final String value) { super(); this.value = Short.parseShort(value); }
public MutableShort(String value) throws NumberFormatException { super(); this.value = Short.parseShort(value); }
@Override public Short formatTrimmed(String raw) throws Exception { return Short.parseShort(raw); }
public MutableShort(String value) { this.value = Short.parseShort(value); }
public static Short castToShort(Object val) { if (val == null || val == EVAL_VALUE_NULL) { return null; } if (val instanceof Short) { return (Short) val; } if (val instanceof String) { return Short.parseShort((String) val); } return ((Number) val).shortValue(); }
public short asShort() { switch (type) { case stringValue: return Short.parseShort(stringValue); case doubleValue: return (short) doubleValue; case longValue: return (short) longValue; case booleanValue: return longValue != 0 ? (short) 1 : 0; } throw new IllegalStateException("Value cannot be converted to short: " + type); }
public short asShort() { switch (type) { case stringValue: return Short.parseShort(stringValue); case doubleValue: return (short) doubleValue; case longValue: return (short) longValue; case booleanValue: return longValue != 0 ? (short) 1 : 0; } throw new IllegalStateException("Value cannot be converted to short: " + type); }
@Override public short getShort(int columnIndex) { Object value = results[resultsIndex][columnIndex]; return value == null ? 0 : (value instanceof Number ? ((Number) value).shortValue() : Short.parseShort(value.toString())); }
@Override public short convertToShort(CharSequence value) { if (value instanceof AsciiString) { return ((AsciiString) value).parseShort(); } return Short.parseShort(value.toString()); }
@Override public short getShort(String name) { return Short.parseShort(getFieldValue(name)); }
public static long smallintPartitionKey(String value, String name) { try { return parseShort(value); } catch (NumberFormatException e) { throw new PrestoException(HIVE_INVALID_PARTITION_VALUE, format("Invalid partition value '%s' for SMALLINT partition key: %s", value, name)); } }
@Override public short convertToShort(CharSequence value) { if (value instanceof AsciiString) { return ((AsciiString) value).parseShort(); } return Short.parseShort(value.toString()); }
public short getParameter(String key, short defaultValue) { Number n = getNumbers().get(key); if (n != null) { return n.shortValue(); } String value = getParameter(key); if (StringUtils.isEmpty(value)) { return defaultValue; } short s = Short.parseShort(value); getNumbers().put(key, s); return s; }
public short getParameter(String key, short defaultValue) { Number n = getNumbers().get(key); if (n != null) { return n.shortValue(); } String value = getParameter(key); if (StringUtils.isEmpty(value)) { return defaultValue; } short s = Short.parseShort(value); getNumbers().put(key, s); return s; }
public short getMethodParameter(String method, String key, short defaultValue) { String methodKey = method + "." + key; Number n = getNumbers().get(methodKey); if (n != null) { return n.shortValue(); } String value = getMethodParameter(method, key); if (StringUtils.isEmpty(value)) { return defaultValue; } short s = Short.parseShort(value); getNumbers().put(methodKey, s); return s; }
public short getMethodParameter(String method, String key, short defaultValue) { String methodKey = method + "." + key; Number n = getNumbers().get(methodKey); if (n != null) { return n.shortValue(); } String value = getMethodParameter(method, key); if (StringUtils.isEmpty(value)) { return defaultValue; } short s = Short.parseShort(value); getNumbers().put(methodKey, s); return s; }
public Short getShort(String key) { String val = getString(key); if (StringKit.isNotBlank(val)) { return Short.parseShort(val); } return null; }
public Short getShort(String key) { String val = getString(key); if (StringKit.isNotBlank(val)) { return Short.parseShort(val); } return null; }
@LiteralParameters("x") @ScalarOperator(CAST) @SqlType(StandardTypes.SMALLINT) public static long castToSmallint(@SqlType("varchar(x)") Slice slice) { try { return Short.parseShort(slice.toStringUtf8()); } catch (Exception e) { throw new PrestoException(INVALID_CAST_ARGUMENT, format("Cannot cast '%s' to SMALLINT", slice.toStringUtf8())); } }