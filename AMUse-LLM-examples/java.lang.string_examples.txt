private boolean isMyServiceRunning(Class<?> serviceClass) { ActivityManager manager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); for (RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) { if (serviceClass.getName().equals(service.service.getClassName())) { return true; } } return false; }
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { Action action = ActionFactory.getAction(request); String view = action.execute(request, response); if (view.equals(request.getPathInfo().substring(1))) { request.getRequestDispatcher("/WEB-INF/" + view + ".jsp").forward(request, response); } else { response.sendRedirect(view); } } catch (Exception e) { throw new ServletException("Executing action failed.", e); } }
@Override public boolean test(String value) { return "d".equals(value); }
@Override public boolean test(String t1) { return t1.equals("two"); }
@Override public boolean test(String t1) { return t1.equals("two"); }
@Override public String apply(String s) { if (s.equals("x")) { return "xx"; } return s.toUpperCase(); } 
@Override public String apply(String t1) { if ("b".equals(t1)) { throw new RuntimeException("Forced failure"); } return t1 + t1; } 
@Override public String apply(String s) { if (s.equals("x")) { return "xx"; } return s.toUpperCase(); } 
@Override public String apply(String t1) { if ("bb".equals(t1)) { throw new RuntimeException("Forced failure"); } return t1 + t1; } 
@Override public String apply(String t1) { if ("bb".equals(t1)) { throw new RuntimeException("Forced failure"); } return t1 + t1; } 
@Override public void accept(String s) { if ("fail".equals(s)) { throw new RuntimeException("Forced Failure"); } } 
@Override public String apply(String s) { if ("fail".equals(s)) { throw new RuntimeException("Forced Failure"); } System.out.println("BadMapper:" + s); return s; } 
@Override public String apply(String s) { if ("fail".equals(s)) { throw new RuntimeException("Forced Failure"); } System.out.println("BadMapper:" + s); return s; } 
@Override public Integer apply(String t1) { if ("b".equals(t1)) { throw new RuntimeException("Forced Failure"); } return t1.length(); }
@Override public String apply(String s) { if ("fail".equals(s)) { throw new RuntimeException("Forced Failure"); } System.out.println("BadMapper:" + s); return s; } 
@Override public Integer apply(String t1) { if ("bb".equals(t1)) { throw new RuntimeException("Forced Failure"); } return t1.length(); }
@Override public Integer apply(String t1) { if ("bb".equals(t1)) { throw new RuntimeException("Forced Failure"); } return t1.length(); }
@Override public Integer apply(String t1) { if ("b".equals(t1)) { throw new RuntimeException("Forced Failure"); } return t1.length(); }
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List<Part> fileParts = request.getParts().stream().filter(part -> "file".equals(part.getName())).collect(Collectors.toList()); for (Part filePart : fileParts) { String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString(); InputStream fileContent = filePart.getInputStream(); } }
@Override public String apply(Integer t) { assertTrue(Thread.currentThread().getName().equals(currentThreadName)); return "Value_" + t + "_Thread_" + Thread.currentThread().getName(); }
public void postRequest(String urlStr, String jsonBodyStr) throws IOException { URL url = new URL(urlStr); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setDoOutput(true); httpURLConnection.setRequestMethod("POST"); httpURLConnection.setRequestProperty("Content-Type", "application/json"); try (OutputStream outputStream = httpURLConnection.getOutputStream()) { outputStream.write(jsonBodyStr.getBytes()); outputStream.flush(); } if (httpURLConnection.getResponseCode() == HttpURLConnection.HTTP_OK) { try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(httpURLConnection.getInputStream()))) { String line; while ((line = bufferedReader.readLine()) != null) { // ... do something with line } } } else { // ... do something with unsuccessful response } }
public void testRfc2202_hmacMd5_case2() { byte[] key = "Jefe".getBytes(UTF_8); String data = "what do ya want for nothing?"; checkMd5("750c783e6ab0b503eaa86e310a5db738", key, data); }
private static Manifest manifest(String content) throws IOException { InputStream in = new ByteArrayInputStream(content.getBytes(US_ASCII)); Manifest manifest = new Manifest(); manifest.read(in); return manifest; }
public void testRfc2202_hmacSha1_case2() { byte[] key = "Jefe".getBytes(UTF_8); String data = "what do ya want for nothing?"; checkSha1("effcdf6ae5eb2fa2d27416d5f184df9c259a7c79", key, data); }
public void testSomeOtherKnownValues() { assertCrc(0x22620404, "The quick brown fox jumps over the lazy dog".getBytes(UTF_8)); assertCrc(0xE3069283, "123456789".getBytes(UTF_8)); assertCrc(0xf3dbd4fe, "1234567890".getBytes(UTF_8)); assertCrc(0xBFE92A83, "23456789".getBytes(UTF_8)); }
@SuppressWarnings("deprecation") public void testWriteBytes() throws IOException { /* Write out various test values in LITTLE ENDIAN FORMAT */ out.writeBytes("r\u00C9sum\u00C9"); byte[] data = baos.toByteArray(); /* Setup input streams */ DataInput in = new DataInputStream(new ByteArrayInputStream(data)); /* Read in various values NORMALLY */ byte[] b = new byte[6]; in.readFully(b); assertEquals("r\u00C9sum\u00C9".getBytes(Charsets.ISO_8859_1), b); }
public void testNullOutputStream() throws Exception { OutputStream nos = ByteStreams.nullOutputStream(); nos.write('n'); String test = "Test string for NullOutputStream"; nos.write(test.getBytes()); nos.write(test.getBytes(), 2, 10); assertSame(ByteStreams.nullOutputStream(), ByteStreams.nullOutputStream()); }
public void testKnownInputs() throws Exception { String knownOutput = "9753980fe94daa8ecaa82216519393a9"; String input = "The quick brown fox jumps over the lazy dog"; Mac mac = Mac.getInstance("HmacMD5"); mac.init(MD5_KEY); mac.update(input.getBytes(UTF_8)); assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal()).toString()); assertEquals(knownOutput, HashCode.fromBytes(mac.doFinal(input.getBytes(UTF_8))).toString()); assertEquals(knownOutput, Hashing.hmacMd5(MD5_KEY).hashString(input, UTF_8).toString()); assertEquals(knownOutput, Hashing.hmacMd5(MD5_KEY).hashBytes(input.getBytes(UTF_8)).toString()); }
@GwtIncompatible private static void testStreamingDecodes(BaseEncoding encoding, String encoded, String decoded) throws IOException { byte[] bytes = decoded.getBytes(UTF_8); InputStream decodingStream = encoding.decodingStream(new StringReader(encoded)); for (int i = 0; i < bytes.length; i++) { assertThat(decodingStream.read()).isEqualTo(bytes[i] & 0xFF); } assertThat(decodingStream.read()).isEqualTo(-1); decodingStream.close(); }
public void testReallySimpleFingerprints() { assertEquals(8581389452482819506L, fingerprint("test".getBytes(UTF_8))); assertEquals(-4196240717365766262L, fingerprint(Strings.repeat("test", 8).getBytes(UTF_8))); assertEquals(3500507768004279527L, fingerprint(Strings.repeat("test", 64).getBytes(UTF_8))); }
public void testInvalidUnicodeHasherPutString() { String str = new String( new char[] {'a', Character.MIN_HIGH_SURROGATE, Character.MIN_HIGH_SURROGATE, 'z'}); assertEquals( murmur3_32().hashBytes(str.getBytes(Charsets.UTF_8)), murmur3_32().newHasher().putString(str, Charsets.UTF_8).hash()); }}
public void testUtf16Expected() { byte[] hardcodedExpected = utf16ExpectedWithBom; byte[] computedExpected = "r\u00C9sum\u00C9".getBytes(Charsets.UTF_16); assertEquals(hardcodedExpected, computedExpected); }
@SuppressWarnings("deprecation") public void testSimpleStringUtf8() { assertEquals(murmur3_32().hashBytes("ABCDefGHI\u0799".getBytes(Charsets.UTF_8)), murmur3_32().hashString("ABCDefGHI\u0799", Charsets.UTF_8)); }
public void testHash() throws IOException { ByteSource byteSource = new TestByteSource("hamburger\n".getBytes(Charsets.US_ASCII)); assertEquals("cfa0c5002275c90508338a5cdb2a9781", byteSource.hash(Hashing.md5()).toString()); }
public void testNewDataInput_readUTF() { byte[] data = new byte[17]; data[1] = 15; System.arraycopy("Kilroy was here".getBytes(Charsets.UTF_8), 0, data, 2, 15); ByteArrayDataInput in = ByteStreams.newDataInput(data); assertEquals("Kilroy was here", in.readUTF()); }
public void testToByteArray() throws IOException { File asciiFile = getTestFile("ascii.txt"); File i18nFile = getTestFile("i18n.txt"); assertTrue(Arrays.equals(ASCII.getBytes(Charsets.US_ASCII), Files.toByteArray(asciiFile))); assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8), Files.toByteArray(i18nFile))); assertTrue(Arrays.equals(I18N.getBytes(Charsets.UTF_8), Files.asByteSource(i18nFile).read())); }
static TestSuite suiteForString(ByteSourceFactory factory, String string, String name, String desc) { TestSuite suite = suiteForBytes(factory, string.getBytes(Charsets.UTF_8), name, desc, true); CharSourceFactory charSourceFactory = SourceSinkFactories.asCharSourceFactory(factory); suite.addTest(CharSourceTester.suiteForString(charSourceFactory, string, name + ".asCharSource[Charset]", desc)); return suite; }
public void testNewDataOutput_writeUTF() { ByteArrayDataOutput out = ByteStreams.newDataOutput(); out.writeUTF("r\u00C9sum\u00C9"); byte[] expected = "r\u00C9sum\u00C9".getBytes(Charsets.UTF_8); byte[] actual = out.toByteArray(); assertEquals(0, actual[0]); assertEquals(expected.length, actual[1]); assertEquals(expected, Arrays.copyOfRange(actual, 2, actual.length)); }
public void testNullPointers() { NullPointerTester tester = new NullPointerTester().setDefault(byte[].class, "secret key".getBytes(UTF_8)).setDefault(HashCode.class, HashCode.fromLong(0)); tester.testAllPublicStaticMethods(Hashing.class); }
public void testNewDataInput_readChar() { byte[] data = "qed".getBytes(Charsets.UTF_16BE); ByteArrayDataInput in = ByteStreams.newDataInput(data); assertEquals('q', in.readChar()); assertEquals('e', in.readChar()); assertEquals('d', in.readChar()); }