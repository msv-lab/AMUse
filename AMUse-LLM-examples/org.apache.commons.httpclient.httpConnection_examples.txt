httpConnection = new HttpConnection(hostConfiguration); httpConnection.setHttpConnectionManager(this); httpConnection.getParams().setDefaults(this.params); } else { || !hostConfiguration.proxyEquals(httpConnection)) { if (httpConnection.isOpen()) { httpConnection.close(); httpConnection.setHost(hostConfiguration.getHost()); httpConnection.setPort(hostConfiguration.getPort()); httpConnection.setProtocol(hostConfiguration.getProtocol()); httpConnection.setLocalAddress(hostConfiguration.getLocalAddress()); httpConnection.setProxyHost(hostConfiguration.getProxyHost()); httpConnection.setProxyPort(hostConfiguration.getProxyPort()); } else { finishLastResponse(httpConnection);
responseConnection.setLastResponseInputStream(null); if (shouldCloseConnection(responseConnection)) { responseConnection.close(); } else { try { if(responseConnection.isResponseAvailable()) { boolean logExtraInput = getParams().isParameterTrue(HttpMethodParams.WARN_EXTRA_INPUT); responseConnection.close(); responseConnection.close(); ensureConnectionRelease();
static void finishLastResponse(HttpConnection conn) { InputStream lastResponse = conn.getLastResponseInputStream(); if (lastResponse != null) { conn.setLastResponseInputStream(null); try { lastResponse.close(); } catch (IOException ioe) { conn.close(); } } }
public HttpConnection getConnectionWithTimeout(HostConfiguration hostConfiguration, long timeout) { httpConnection = new HttpConnection(hostConfiguration); httpConnection.setHttpConnectionManager(this); httpConnection.getParams().setDefaults(connectionParams); return httpConnection; }        
public boolean closeIfStale() throws IOException { if (isOpen && isStale()) { LOG.debug("Connection is stale, closing..."); close(); return true; } return false; }
LOG.trace("enter HttpMethodBase.writeRequest(HttpState, HttpConnection)"); writeRequestLine(state, conn); writeRequestHeaders(state, conn); conn.writeLine(); // close head if (Wire.HEADER_WIRE.enabled()) { Wire.HEADER_WIRE.output("\r\n"); conn.flushRequestOutputStream(); int readTimeout = conn.getParams().getSoTimeout(); try { conn.setSocketTimeout(RESPONSE_WAIT_TIME_MS); readStatusLine(state, conn); processStatusLine(state, conn); LOG.info("100 (continue) read timeout. Resume sending the request"); } finally { conn.setSocketTimeout(readTimeout); writeRequestBody(state, conn); conn.flushRequestOutputStream(); }
InputStream is = conn.getResponseInputStream(); if (Wire.CONTENT_WIRE.enabled()) { is = new WireLogInputStream(is, Wire.CONTENT_WIRE); } boolean canHaveBody = canResponseHaveBody(statusLine.getStatusCode()); InputStream result = null; Header transferEncodingHeader = responseHeaders.getFirstHeader("Transfer-Encoding"); String transferEncoding = transferEncodingHeader.getValue(); if (!"chunked".equalsIgnoreCase(transferEncoding) && !"identity".equalsIgnoreCase(transferEncoding)) { HeaderElement[] encodings = transferEncodingHeader.getElements(); if ((len > 0) && ("chunked".equalsIgnoreCase(encodings[len - 1].getName()))) { if (conn.isResponseAvailable(conn.getParams().getSoTimeout())) { result = new ChunkedInputStream(is, this); } else { if (getParams().isParameterTrue(HttpMethodParams.STRICT_TRANSFER_ENCODING)) { throw new ProtocolException("Chunk-encoded body declared but not sent"); } else { setConnectionCloseForced(true); result = is; } } }
public boolean unsubscribe(String uri, Subscriber listener, Credentials credentials) { UnsubscribeMethod unsubscribeMethod = new UnsubscribeMethod(repositoryDomain+uri); synchronized ( subscribers ) { for ( Iterator i = subscribers.iterator(); i.hasNext(); ) { Subscription subscription = (Subscription)i.next(); if ( subscription.getSubscriber().equals(listener) ) { String id = String.valueOf(subscription.getId()); unsubscribeMethod.addRequestHeader(UnsubscribeMethod.H_SUBSCRIPTION_ID, id); try { unsubscribeMethod.setDoAuthentication(true); HttpState httpState = new HttpState(); httpState.setCredentials(null, repositoryHost, credentials); HttpConnection httpConnection = new HttpConnection(repositoryHost, repositoryPort, protocol); httpConnection.setConnectionTimeout(CONNECTION_TIMEOUT); int state = unsubscribeMethod.execute(httpState, httpConnection); if ( state == HttpStatus.SC_OK ) { i.remove(); return true; } else { logger.log(Level.SEVERE, "Unsubscription failed. State: "+state); } } catch (IOException e) { logger.log(Level.SEVERE, "Unsubscription of listener '"+listener+"' failed!", e); } } } } logger.log(Level.SEVERE, "Listener not unsubscribed!"); return false; }
protected void fireEvent(EventMethod eventMethod, Credentials credentials) throws IOException { eventMethod.setDoAuthentication(true); HttpState httpState = new HttpState(); httpState.setCredentials(null, repositoryHost, credentials); int state = eventMethod.execute(httpState, new HttpConnection(repositoryHost, repositoryPort, protocol)); if ( state == HttpStatus.SC_OK ) { } else { logger.log(Level.SEVERE, "Event failed. State: "+state); } }
this.connectMethod.getParams().setDefaults(this.hostConfiguration.getParams()); if (!this.conn.isOpen()) { this.conn.open(); || this.state.isAuthenticationPreemptive()) { LOG.debug("Preemptively sending default basic credentials"); this.connectMethod.getProxyAuthState().setPreemptive(); this.conn.tunnelCreated(); this.conn.close(); return false;
LOG.trace("Attempt number " + execCount + " to process request"); if (this.conn.getParams().isStaleCheckingEnabled()) { this.conn.closeIfStale(); } if (!this.conn.isOpen()) { this.conn.open(); } if (this.conn.isProxied() && this.conn.isSecure() && !(method instanceof ConnectMethod)) {} catch (IOException e) { LOG.debug("Closing the connection."); this.conn.close(); ((HttpMethodBase)method).getMethodRetryHandler(); } if (handler != null) { if (!handler.retryMethod(if (this.conn.isOpen()) { LOG.debug("Closing the connection."); this.conn.close(); if (this.conn.isOpen()) { LOG.debug("Closing the connection."); this.conn.close();
checkExecuteConditions(state, conn); this.statusLine = null; this.connectionCloseForced = false; conn.setLastResponseInputStream(null); this.effectiveVersion = this.params.getVersion(); writeRequest(state, conn); this.requestSent = true; readResponse(state, conn);
private void applyConnectionParams(final HttpMethod method) throws IOException { int timeout = 0; Object param = method.getParams().getParameter(HttpMethodParams.SO_TIMEOUT); if (param == null) { param = this.conn.getParams().getParameter(HttpConnectionParams.SO_TIMEOUT); } if (param != null) { timeout = ((Integer)param).intValue(); } this.conn.setSocketTimeout(timeout); }
public void close() { if (httpConnection != null) { if (httpConnection.isOpen()) { releaseConnection(httpConnection); } httpConnection.close(); } httpConnection = null; conn = null; } }
public void shutdown() { httpConnection.close(); }
connection.close(); connection.setHttpConnectionManager(null); connection.releaseConnection();
InputStream stream = readResponseBody(conn); if (stream == null) { responseBodyConsumed(); } else { conn.setLastResponseInputStream(stream); setResponseStream(stream);
method.getParams().setDefaults(getParams()); response.setSocket(connectionManager.getConnection().getSocket()); } else { connectionManager.getConnection().close();
public boolean isOpen() { if (hasConnection()) { return wrappedConnection.isOpen(); } else { return false; } }
public void setLastResponseInputStream(InputStream inStream) { if (hasConnection()) { wrappedConnection.setLastResponseInputStream(inStream); } else { } }