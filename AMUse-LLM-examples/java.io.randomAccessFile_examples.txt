public long length() { try { if (!exists()) { return 0; } RandomAccessFile raf = new RandomAccessFile(this, "r"); long len = raf.length(); raf.close(); return len; } catch (IOException e) { return 0; } }
private byte[] readFile(File file) throws IOException { RandomAccessFile raf = new RandomAccessFile(file, "r"); byte[] buffer = new byte[(int) raf.length()]; raf.readFully(buffer); raf.close(); return buffer; }
public synchronized void reopen(long lastPosition) throws IOException { if (isClosed) { throw new IOException("Random Access File is closed"); } try { this.raf.close(); } catch (IOException e) { /* ignore */ } this.raf = new RandomAccessFile(file, mode); this.raf.seek(lastPosition); }
public static void aMethod(){ RandomAccessFile f = new RandomAccessFile(new File("whereDidIPutTHatFile"), "rw"); long aPositionWhereIWantToGo = 99; f.seek(aPositionWhereIWantToGo); f.write("Im in teh fil, writn bites".getBytes()); f.close(); }
public void close() throws IOException { RandomAccessFile raf = mRaf; if (raf != null) { mRaf = null; raf.close(); if (fileToDeleteOnClose != null) { new File(fileName).delete(); fileToDeleteOnClose = null; } } }
try { randomAccessWriter.write(buffer); payloadSize += buffer.length; if (bSamples == 16) randomAccessWriter = new RandomAccessFile(filePath, "rw"); randomAccessWriter.close(); (new File(filePath)).delete(); randomAccessWriter.seek(4); randomAccessWriter.writeInt(Integer.reverseBytes(36+payloadSize)); randomAccessWriter.seek(40); randomAccessWriter.writeInt(Integer.reverseBytes(payloadSize)); randomAccessWriter.close(); }
@Before public void setup() throws IOException { String dir = DIR.getRoot().getPath(); File infile = new File(dir + "/in"); RandomAccessFile file = new RandomAccessFile(infile, "rw"); file.writeChars("aa bb cc\ndd ee ff\n"); file.close(); }
throws Exception { String fileName = "test_single_col.dat"; File f = new File(fileName); RandomAccessFile raf = new RandomAccessFile(f, "rw"); raf.close();
public static byte[] readBytes(File file, int fixedLength) throws IOException { if (!file.exists()) { throw new FileNotFoundException(MSG_NOT_FOUND + file); } if (!file.isFile()) { throw new IOException(MSG_NOT_A_FILE + file); } long len = file.length(); if (len >= Integer.MAX_VALUE) { throw new IOException("File is larger then max array size"); } if (fixedLength > -1 && fixedLength < len) { len = fixedLength; } byte[] bytes = new byte[(int) len]; RandomAccessFile randomAccessFile = new RandomAccessFile(file, "r"); randomAccessFile.readFully(bytes); randomAccessFile.close(); return bytes; }
public static void toFile(@NonNull ByteBuffer buffer, @NonNull File file) throws IOException { buffer.position(0); RandomAccessFile raf = null; FileChannel channel = null; try { raf = new RandomAccessFile(file, "rw"); channel = raf.getChannel(); channel.write(buffer); channel.force(false /*metadata*/); channel.close(); raf.close(); } finally { if (channel != null) { try { channel.close(); } catch (IOException e) { // Ignored. } } if (raf != null) { try { raf.close(); } catch (IOException e) { // Ignored. } } } }
RandomAccessFile raf = new RandomAccessFile(file, "rw"); if (skip < 0 || skip > raf.length()) { System.out.println("skip error"); return; } raf.setLength(raf.length() + b.length); for (long i = raf.length() - 1; i > b.length + skip - 1; i--) { raf.seek(i - b.length); byte temp = raf.readByte(); raf.seek(i); raf.writeByte(temp); raf.seek(skip); raf.write(b); raf.close(); } catch (Exception e) { e.printStackTrace(); }
@Test public void testNegativeSizeInHeaderThrows() throws IOException { RandomAccessFile emptyFile = new RandomAccessFile(file, "rwd"); emptyFile.seek(0); emptyFile.writeInt(-2147483648); emptyFile.setLength(INITIAL_LENGTH); emptyFile.getChannel().force(true); emptyFile.close(); try { newQueueFile(); fail("Should have thrown about bad header length"); } catch (IOException ex) { assertThat(ex.getMessage()).isIn(Arrays.asList("File is corrupt; length stored in header (-2147483648) is invalid.", "Unable to read version 0 format. Supported versions are 1 and legacy.")); } }
@Test public void testSizeLessThanHeaderThrows() throws IOException { RandomAccessFile emptyFile = new RandomAccessFile(file, "rwd"); emptyFile.setLength(INITIAL_LENGTH); if (forceLegacy) { emptyFile.writeInt(headerLength - 1); } else { emptyFile.writeInt(0x80000001); emptyFile.writeLong(headerLength - 1); } emptyFile.getChannel().force(true); emptyFile.close(); try { newQueueFile(); fail(); } catch (IOException ex) { assertThat(ex.getMessage()).isIn(Arrays.asList("File is corrupt; length stored in header (15) is invalid.", "File is corrupt; length stored in header (31) is invalid.")); } }
private void corruptFile(File f) throws IOException { RandomAccessFile outFile = new RandomAccessFile(f, "rw"); outFile.write("fail servers".getBytes()); outFile.close(); }
private int copy(InputStream in, RandomAccessFile out) throws IOException, UpdateError { byte[] buffer = new byte[BUFFER_SIZE]; BufferedInputStream bis = new BufferedInputStream(in, BUFFER_SIZE); try { out.seek(out.length()); int bytes = 0; long previousBlockTime = -1; while (!isCancelled()) { int n = bis.read(buffer, 0, BUFFER_SIZE); if (n == -1) { break; } out.write(buffer, 0, n); bytes += n; checkNetwork(); if (mSpeed != 0) { previousBlockTime = -1; } else if (previousBlockTime == -1) { previousBlockTime = System.currentTimeMillis(); } else if ((System.currentTimeMillis() - previousBlockTime) > TIME_OUT) { throw new UpdateError(UpdateError.DOWNLOAD_NETWORK_TIMEOUT); } } return bytes; } finally { out.close(); bis.close(); in.close(); } }
public Void perform() { RandomAccessFile raf = null; try { String path = vertx.resolveFile(p).getAbsolutePath(); if (len < 0) { throw new FileSystemException("Cannot truncate file to size < 0"); } if (!Files.exists(Paths.get(path))) { throw new FileSystemException("Cannot truncate file " + path + ". Does not exist"); } try { raf = new RandomAccessFile(path, "rw"); raf.setLength(len); } finally { if (raf != null) raf.close(); } } catch (IOException e) { throw new FileSystemException(e); } return null; }};
private void reset() throws IOException { RandomAccessFile randomAccessFile = this.randomAccessFile; if (randomAccessFile == null) { return; } try { scratchByteBuffer.clear(); scratchByteBuffer.putInt(bytesWritten - 8); randomAccessFile.seek(FILE_SIZE_MINUS_8_OFFSET); randomAccessFile.write(scratchBuffer, 0, 4); scratchByteBuffer.clear(); scratchByteBuffer.putInt(bytesWritten - 44); randomAccessFile.seek(FILE_SIZE_MINUS_44_OFFSET); randomAccessFile.write(scratchBuffer, 0, 4); } catch (IOException e) { Log.w(TAG, "Error updating file size", e); } try { randomAccessFile.close(); } finally { this.randomAccessFile = null; } }
StringBuffer sb = new StringBuffer(); try { endPos = raf.length(); lastPos = endPos; raf.seek(endPos - 1); raf.read(oneByte); if ((char) oneByte[0] != '\n') { pos = lastPos - BUFFERSIZE; raf.seek(pos); raf.seek(pos); if ((endPos - pos) < BUFFERSIZE) { int remainer = (int) (endPos - pos); info = buildDisplayingHeader(sb.length(), raf.length()); } } catch (FileNotFoundException e) { sb = null; try { if (raf != null) { raf.close();
public void testEqual() throws IOException { File asciiFile = getTestFile("ascii.txt"); File i18nFile = getTestFile("i18n.txt"); assertFalse(Files.equal(asciiFile, i18nFile)); assertTrue(Files.equal(asciiFile, asciiFile)); File temp = createTempFile(); Files.copy(asciiFile, temp); assertTrue(Files.equal(asciiFile, temp)); Files.copy(i18nFile, temp); assertTrue(Files.equal(i18nFile, temp)); Files.copy(asciiFile, temp); RandomAccessFile rf = new RandomAccessFile(temp, "rw"); rf.writeByte(0); rf.close(); assertEquals(asciiFile.length(), temp.length()); assertFalse(Files.equal(asciiFile, temp)); assertTrue(Files.asByteSource(asciiFile).contentEquals(Files.asByteSource(asciiFile))); assertTrue(Files.equal(asciiFile, new BadLengthFile(asciiFile, 0))); }
public void close() throws IOException { file.getChannel().force(true); file.close(); }