@Override public Optional<Interval> bucketInterval(DateTime dt) { final Interval interval = intervals.floor(new Interval(dt, DateTimes.MAX)); if (interval != null && interval.contains(dt)) { return Optional.of(interval); } else { return Optional.absent(); } }
@Override public Interval next() { if (!hasNext()) { throw new NoSuchElementException("There are no more intervals"); } Interval retVal = new Interval(currStart, currEnd); currStart = currEnd; currEnd = increment(currStart); return retVal; }
private QueueEntry(List<DataSegment> segments){ Preconditions.checkArgument(segments != null && !segments.isEmpty()); Collections.sort(segments); this.interval = new Interval( segments.get(0).getInterval().getStart(), segments.get(segments.size() - 1).getInterval().getEnd() ); this.segments = segments; }
public final Interval bucket(DateTime t) { DateTime start = bucketStart(t); return new Interval(start, increment(start)); }
public Interval getMergedTimelineInterval() { if (timelineObjects.isEmpty()) { return null; } else { return new Interval(timelineObjects.get(0).lhs.getInterval().getStart(), timelineObjects.get(timelineObjects.size() - 1).lhs.getInterval().getEnd()); } }
private Interval getIntervalOrDefault(Interval interval) { final Interval theInterval; if (interval == null) { DateTime now = DateTimes.nowUtc(); theInterval = new Interval(now.minus(config.getAuditHistoryMillis()), now); } else { theInterval = interval; } return theInterval; }
@Override public boolean appliesTo(Interval theInterval, DateTime referenceTimestamp) { final Interval currInterval = new Interval(period, referenceTimestamp); if (includeFuture) { return currInterval.getStartMillis() <= theInterval.getStartMillis(); } else { return currInterval.contains(theInterval); } }
public static boolean eligibleForLoad(Period period, Interval interval, DateTime referenceTimestamp, boolean includeFuture) { final Interval currInterval = new Interval(period, referenceTimestamp); if (includeFuture) { return currInterval.getStartMillis() < interval.getEndMillis(); } else { return eligibleForLoad(currInterval, interval); } }
public static Interval shifted1HInterval(DateTime REFERENCE_TIME, int shiftInHours){ return new Interval( REFERENCE_TIME.plusHours(shiftInHours), REFERENCE_TIME.plusHours(shiftInHours + 1)); }
public Interval getInterval(){ DateTime min = DateTimes.utc(minTimestamp); return new Interval(min, isEmpty() ? min : gran.increment(DateTimes.utc(getMaxTimeMillis()))); }
@Test public void testIterableAllSimple(){ final DateTime baseTime = DateTimes.of("2011-01-01T00:00:00.000Z"); assertSameInterval( Collections.singletonList(baseTime), Granularities.ALL.getIterable(new Interval(baseTime, baseTime.plus(Days.days(3)))) ); }
@Test public void testIterableAllComplex(){ final DateTime baseTime = DateTimes.of("2011-01-01T09:38:02.992Z"); assertSameInterval( Collections.singletonList(baseTime), Granularities.ALL.getIterable(new Interval(baseTime, baseTime.plus(Days.days(3)))) ); }
@Override public Interval getDataInterval(){ return new Interval(DateTimes.nowUtc().minus(Days.days(1)), DateTimes.nowUtc()); }
@Test public void testIterableQuarterSimple() { final DateTime baseTime = DateTimes.of("2011-01-01T00:00:00.000Z"); assertSameInterval( Lists.newArrayList( DateTimes.of("2011-01-01T00:00:00.000Z"), DateTimes.of("2011-04-01T00:00:00.000Z"), DateTimes.of("2011-07-01T00:00:00.000Z") ), Granularities.QUARTER.getIterable(new Interval(baseTime, baseTime.plus(Months.NINE))) ); }
@Test public void testIterableYearSimple() { final DateTime baseTime = DateTimes.of("2011-01-01T00:00:00.000Z"); assertSameInterval( Lists.newArrayList( DateTimes.of("2011-01-01T00:00:00.000Z"), DateTimes.of("2012-01-01T00:00:00.000Z"), DateTimes.of("2013-01-01T00:00:00.000Z") ), Granularities.YEAR.getIterable(new Interval(baseTime, baseTime.plus(Years.THREE))) ); }
@Test public void testIterableHourSimple() { final DateTime baseTime = DateTimes.of("2011-01-01T09:00:00.000Z"); assertSameInterval( Lists.newArrayList( DateTimes.of("2011-01-01T09:00:00.000Z"), DateTimes.of("2011-01-01T10:00:00.000Z"), DateTimes.of("2011-01-01T11:00:00.000Z") ), Granularities.HOUR.getIterable(new Interval(baseTime, baseTime.plus(Hours.hours(3)))) ); }
@Test public void testUsedOutOfBoundsHigh() throws IOException{ coordinator.announceHistoricalSegments(SEGMENTS); Assert.assertTrue(coordinator.getUsedSegmentsForInterval( defaultSegment.getDataSource(), new Interval(defaultSegment.getInterval().getEnd(), defaultSegment.getInterval().getEnd().plusDays(10))).isEmpty() ); }
@Test public void testUnUsedUnderlapLow() throws IOException{ coordinator.announceHistoricalSegments(SEGMENTS); unUseSegment(); Assert.assertTrue(coordinator.getUnusedSegmentsForInterval(defaultSegment.getDataSource(), new Interval(defaultSegment.getInterval().getStart().plus(1), defaultSegment.getInterval().getEnd())).isEmpty()); }
@Test public void testUsedOutOfBoundsLow() throws IOException{ coordinator.announceHistoricalSegments(SEGMENTS); Assert.assertTrue(coordinator.getUsedSegmentsForInterval(defaultSegment.getDataSource(), new Interval(defaultSegment.getInterval().getStart().minus(1), defaultSegment.getInterval().getStart())).isEmpty()); }
@Test public void testUnUsedUnderlapHigh() throws IOException{ coordinator.announceHistoricalSegments(SEGMENTS); unUseSegment(); Assert.assertTrue(coordinator.getUnusedSegmentsForInterval(defaultSegment.getDataSource(), new Interval(defaultSegment.getInterval().getStart(), defaultSegment.getInterval().getEnd().minus(1))).isEmpty()); }