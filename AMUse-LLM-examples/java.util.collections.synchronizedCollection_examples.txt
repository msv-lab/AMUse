public static <T> Collection<T> asSynchronized(Collection<T> self) { return Collections.synchronizedCollection(self); }
public void markDeserialized() { if (items == null || items == Collections.EMPTY_LIST) { items = Collections.emptyList(); } else { items = Collections.synchronizedCollection(items); } }
private Dataset(Builder builder) { this.inputPaths = builder.inputPaths; this.inputLatePaths = builder.inputLatePaths; this.outputPath = builder.outputPath; this.outputLatePath = builder.outputLatePath; this.outputTmpPath = builder.outputTmpPath; this.additionalInputPaths = Sets.newHashSet(); this.throwables = Collections.synchronizedCollection(Lists.<Throwable> newArrayList()); this.priority = builder.priority; this.lateDataThresholdForRecompact = builder.lateDataThresholdForRecompact; this.state = new AtomicReference<>(DatasetState.UNVERIFIED); this.datasetName = builder.datasetName; this.jobProps = builder.jobProps; this.renamePaths = builder.renamePaths; }
public Collection<V> values() { synchronized(mutex) { if(values == null) values=Collections.synchronizedCollection(map.values()); return values; } }
classes.add(Collections.checkedSortedSet(Collections.emptySortedSet(), Void.class).getClass()); classes.add(Collections.synchronizedCollection(randomAccessList).getClass()); classes.add(Collections.synchronizedCollection(nonRandomAccessList).getClass()); classes.add(Collections.synchronizedList(randomAccessList).getClass()); classes.add(Collections.synchronizedList(nonRandomAccessList).getClass());
.synchronizedCollection(Collections.emptyList()); 
public Collection<String> getComponentNames() { return Collections.synchronizedCollection(dirs.values()); }
public static Collection<Object> getFilterdMessage(Collection<Object> sendMsgs, Collection<Object> recvMsgs) { Collection<Object> recvMsgsSync = Collections.synchronizedCollection(recvMsgs); Collection<Object> filterdMsgs = new ArrayList<Object>(); int filterNum = 0; for (Object msg : recvMsgsSync) { if (sendMsgs.contains(msg)) { filterdMsgs.add(msg); } else { filterNum++; } } logger.info(String.format("[%s] messages is filterd!", filterNum)); return filterdMsgs; }
futures.add(pool.submit(() -> { KafkaProducer<String, String> producer = kafkaProducer.get(); Collection<Future<?>> b = Collections.synchronizedCollection(new ArrayList<>()); for (int i = 0; i < batchSize; ++i) { b.add(sendToKafka(producer, kafkaTopic, messageSupplier.get()));
for (AbstractListener listener : listeners) { Collection<Object> recvMsgs = Collections .synchronizedCollection(listener.getAllUndupMsgBody()); noDupMsgs.addAll(VerifyUtils.getFilterdMessage(allSendMsgs, recvMsgs));
@Override public Object create( final Object sourceCollection ) { return Collections.synchronizedCollection( (Collection<?>) sourceCollection ); } },
public static Collection asSynchronized(Collection self) { return Collections.synchronizedCollection(self); }
public void markDeserialized() { if (items == null || items == Collections.EMPTY_LIST) { items = Collections.emptyList(); } else { items = Collections.synchronizedCollection(items); } }
Collection c = Collections.synchronizedCollection(myCollection); synchronized(c) { Iterator i = c.iterator(); while (i.hasNext()) foo(i.next()); }
public Collection<V> values() { synchronized(mutex) { if(values == null) values=Collections.synchronizedCollection(map.values()); return values; } }
public Collection<V> values() { synchronized(mutex) { if(values == null) values=Collections.synchronizedCollection(map.values()); return values; } }
public Collection<V> values() { synchronized(mutex) { if(values == null) values=Collections.synchronizedCollection(map.values()); return values; } }
public static Collection narrowSynchronizedCollection(Collection c) { if (c instanceof SortedSet) return Collections.synchronizedSortedSet((SortedSet) c); else if (c instanceof Set) return Collections.synchronizedSet((Set) c); else if (c instanceof List) return Collections.synchronizedList((List) c); else return Collections.synchronizedCollection(c); }
public Collection<V> values() { synchronized(mutex) { if(values == null) values=Collections.synchronizedCollection(map.values()); return values; } }
void clear() { this.buffer = new byte[0]; updateLastModified(); this.type = FileType.IMAGINARY; this.children = Collections.synchronizedCollection(new ArrayList()); this.name = null; }