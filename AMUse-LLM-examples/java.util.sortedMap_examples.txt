public long startAddress() { if (!addresses.isEmpty()) { return addresses.firstKey(); } else { return 0; } }
public int firstLineCol() { final Integer firstLineKey = lines.firstKey(); return lines.get(firstLineKey); }
public RunT getNearestOldBuild(int n) { SortedMap<Integer, ? extends RunT> m = _getRuns().tailMap(n); if (m.isEmpty()) return null; return m.get(m.firstKey()); }
private synchronized Pair<Long, SocketAddress> get(long hash) { if (circle.isEmpty()) { return null; } if (!circle.containsKey(hash)) { SortedMap<Long, SocketAddress> tailMap = circle.tailMap(hash); hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); } return Pair.of(hash, circle.get(hash)); }
public boolean isFull() { if(map.size() != 1) { return false; } Long min = map.firstKey(); Long max = map.get(min); return min <= range.min && max >= range.max; }
private Long next(long t) { SortedMap<Long, int[]> x = data.tailMap(t + 1); return x.isEmpty() ? null : x.firstKey(); }
private OperationsNodeInfo getNearest(byte[] hash) { if (circle.isEmpty()) { return null; } if (circle.size() == 1) { return circle.get(circle.firstKey()); } SortedMap<byte[], OperationsNodeInfo> tailMap = circle.tailMap(hash); hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); return circle.get(hash); }
public S selectForKey(String key) { SortedMap<Long, S> tail = nodes.tailMap(hash(key)); if (tail.size() == 0) { return nodes.get(nodes.firstKey()); } return tail.get(tail.firstKey()); }
private int at(long t) { SortedMap<Long, int[]> head = data.subMap(t,Long.MAX_VALUE); if (head.isEmpty()) return 0; return data.get(head.firstKey())[0]; }
ClusterNode pickWeightedNode() { int weight = RAND.nextInt(totalWeight) + 1; SortedMap<Integer, ClusterNode> pick = circle.tailMap(weight); assert !pick.isEmpty(); return pick.get(pick.firstKey()); }
public S selectForKey(String key) { SortedMap<Long, S> tail = nodes.tailMap(hash(key)); if (tail.size() == 0) { return nodes.get(nodes.firstKey()); } return tail.get(tail.firstKey()); }
@Override public int getFirstRowNum() { return _rows.isEmpty() ? 0 : _rows.firstKey(); }
public T routeNode(String objectKey) { if (ring.isEmpty()) { return null; } Long hashVal = hashFunction.hash(objectKey); SortedMap<Long, VirtualNode<T>> tailMap = ring.tailMap(hashVal); Long nodeHashVal = !tailMap.isEmpty() ? tailMap.firstKey() : ring.firstKey(); return ring.get(nodeHashVal).getPhysicalNode(); }
ClusterNode pickWeightedNode() { double weight = RAND.nextDouble(); SortedMap<Double, ClusterNode> pick = circle.tailMap(weight); ClusterNode node = pick.get(pick.firstKey()); rwLock.readLock().lock(); try { AtomicInteger cnt = nodeJobs.get(node.id()); if (cnt != null) cnt.incrementAndGet(); } finally { rwLock.readLock().unlock(); } return node; }
@Override public void finishTree(DetailAST rootAST) { if (!lineNumberTypeMap.isEmpty()) { if (!publicTypeFound) { lineNumberTypeMap.remove(lineNumberTypeMap.firstKey()); } for (Map.Entry<Integer, String> entry : lineNumberTypeMap.entrySet()) { log(entry.getKey(), MSG_KEY, entry.getValue()); } } }
public S getShardInfo(byte[] key) { SortedMap<Long, S> tail = nodes.tailMap(algo.hash(key)); if (tail.isEmpty()) { return nodes.get(nodes.firstKey()); } return tail.get(tail.firstKey()); }
Long value = freqTable.get(v); if (value != null) { result = value.longValue(); } if (c.compare(v, freqTable.firstKey()) < 0) { return 0; }
@Override public String firstTagFor(String key) { SortedMap<Tag, Tag> tail = tags.tailMap(new Tag(key, "")); if (!tail.isEmpty()) { Tag f = tail.firstKey(); if (key.equals(f.tagKey)) { return f.tagValue; } } return null; }
public T get(Object key) { if (circle.isEmpty()) { return null; } int hash = hashFunc.hash(key); if (!circle.containsKey(hash)) { SortedMap<Integer, T> tailMap = circle.tailMap(hash); hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); } return circle.get(hash); }
public void testSortOrder() { SortedMap map = makeTestSortedMap(oneFactory); map.put("A",  "a"); map.get("B"); map.put("C", "c"); assertEquals("First key should be A", map.firstKey(), "A"); assertEquals("Last key should be C", map.lastKey(), "C"); assertEquals("First key in tail map should be B", map.tailMap("B").firstKey(), "B"); assertEquals("Last key in head map should be B", map.headMap("C").lastKey(), "B"); assertEquals("Last key in submap should be B", map.subMap("A","C").lastKey(), "B"); Comparator c = map.comparator(); assertTrue("natural order, so comparator should be null", c == null); }