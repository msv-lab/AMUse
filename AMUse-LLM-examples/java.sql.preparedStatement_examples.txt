@Override public PreparedStatement getPreparedStatement(Connection connection, String sql) throws SQLException { connection.setAutoCommit(false); PreparedStatement statement = connection.prepareStatement(sql); statement.setFetchSize(1000); return statement; } }
@Override public PreparedStatement getPreparedStatement(Connection connection, String sql) throws SQLException { connection.setAutoCommit(false); PreparedStatement statement = connection.prepareStatement(sql); statement.setFetchSize(1000); return statement; }
@Override public void openInputFormat() { try { Class.forName(drivername); if (username == null) { dbConn = DriverManager.getConnection(dbURL); } else { dbConn = DriverManager.getConnection(dbURL, username, password); } statement = dbConn.prepareStatement(queryTemplate, resultSetType, resultSetConcurrency); if (fetchSize == Integer.MIN_VALUE || fetchSize > 0) { statement.setFetchSize(fetchSize); } } catch (SQLException se) { throw new IllegalArgumentException("open() failed." + se.getMessage(), se); } catch (ClassNotFoundException cnfe) { throw new IllegalArgumentException("JDBC-Class not found. - " + cnfe.getMessage(), cnfe); } }
private static PreparedStatement newScrollingSelectStatement(DbSession session, String sql, int fetchSize) { try { PreparedStatement stmt = session.getConnection().prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); stmt.setFetchSize(fetchSize); return stmt; } catch (SQLException e) { throw new IllegalStateException("Fail to create SQL statement: " + sql, e); } } }
@Override public String doInConnection(Connection con) throws SQLException { PreparedStatement ps = con.prepareStatement("some SQL"); ps.setFetchSize(10); ps.setMaxRows(20); ps.close(); return "test"; } });
private PreparedStatement createAndCacheScanStatement(StatementType scanType, String key) throws SQLException { String select = dbFlavor.createScanStatement(scanType, key); PreparedStatement scanStatement = getShardConnectionByKey(key).prepareStatement(select); if (this.jdbcFetchSize > 0) { scanStatement.setFetchSize(this.jdbcFetchSize); } PreparedStatement stmt = cachedStatements.putIfAbsent(scanType, scanStatement); if (stmt == null) { return scanStatement; } return stmt; }
public static SelectImpl create(Database db, Connection connection, String sql) throws SQLException { PreparedStatement pstmt = connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); pstmt.setFetchSize(db.getDialect().getScrollDefaultFetchSize()); return new SelectImpl(pstmt); } }
List<TriggerKey> nextTriggers = new LinkedList<TriggerKey>(); try { ps = conn.prepareStatement(rtp(SELECT_NEXT_TRIGGER_TO_ACQUIRE)); ps.setFetchSize(maxCount);
List<TriggerKey> nextTriggers = new LinkedList<TriggerKey>(); try { ps = conn.prepareStatement(rtp(SELECT_NEXT_TRIGGER_TO_ACQUIRE)); ps.setFetchSize(maxCount);
try { List<String> deploymentIds = quartzUtils.getDeployments(); ps = conn.prepareStatement(rtp(quartzUtils.nextTriggerQuery(deploymentIds))); ps.setFetchSize(maxCount);
try { List<String> deploymentIds = quartzUtils.getDeployments(); ps = conn.prepareStatement(rtp(quartzUtils.nextTriggerQuery(deploymentIds))); ps.setFetchSize(maxCount);
ps = conn.prepareStatement(partitionQuery, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); ps.setFetchSize(getFetchSize(conf)); rs = ps.executeQuery();
con = DbConnectionManager.getConnection(); pstmt = con.prepareStatement(LOAD_LAST_ITEM); pstmt.setFetchSize(1); pstmt.setMaxRows(1); pstmt.setString(1, node.getService().getServiceID());
this.dataConnection.prepareStatement(query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); statement.setFetchSize(fetchSize);
conn = openConnection(true); stmt = conn.prepareStatement(lowerBound == null && upperBound == null ? em.loadCacheQry : em.loadCacheRangeQuery(lowerBound != null, upperBound != null)); stmt.setFetchSize(fetchSize);
log.snap( Metrics.METRIC_DATABASE_PREPARE_SQL_START, databaseMeta.getName() ); pstmt = connection.prepareStatement( databaseMeta.stripCR( sql ), ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY ); log.snap( Metrics.METRIC_DATABASE_PREPARE_SQL_STOP, databaseMeta.getName() ); setMysqlFetchSize( pstmt, fs, maxRows ); } else { pstmt.setFetchSize( fs );
private PreparedStatement createStreamingPreparedStatement(String query) throws SQLException { Connection conn = connection(); PreparedStatement res; if ("mysql".equalsIgnoreCase(conn.getMetaData().getDatabaseProductName())) { res = conn.prepareStatement(query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); res.setFetchSize(Integer.MIN_VALUE); } else { res = conn.prepareStatement(query); } return res; }
protected PreparedStatement selectAggregateSQLPS(String function, Expression att, List<Expression> groupByExpressions, SimpleFeatureType featureType, Query query, LimitingVisitor visitor, Connection cx) throws SQLException, IOException { StringBuffer sql = new StringBuffer(); List<FilterToSQL> toSQL = doSelectAggregateSQL(function, att, groupByExpressions, featureType, query, visitor, sql); LOGGER.fine(sql.toString()); PreparedStatement ps = cx.prepareStatement(sql.toString(), ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); ps.setFetchSize(fetchSize); setPreparedFilterValues(ps, toSQL, cx); return ps; }
private PreparedStatement createPreparedStatementInternal(Connection conn, String sql) throws SQLException { PreparedStatement pstmt; if (autoGeneratedKeys != -1) { pstmt = conn.prepareStatement(sql, autoGeneratedKeys); } else if (columnIndexes != null) { pstmt = conn.prepareStatement(sql, columnIndexes); } else if (columnNames != null) { pstmt = conn.prepareStatement(sql, columnNames); } else { int resultSetHoldability = this.resultSetHoldability; if (resultSetHoldability == -1) { resultSetHoldability = conn.getHoldability(); } pstmt = conn.prepareStatement(sql, this.resultSetType, this.resultSetConcurrency, resultSetHoldability); } pstmt.setQueryTimeout(queryTimeout); pstmt.setFetchSize(fetchSize); pstmt.setMaxRows(maxRows); setInnerStatement(pstmt); return pstmt; }
protected PreparedStatement selectSQLPS(SimpleFeatureType featureType, JoiningQuery query, Connection cx) throws SQLException, IOException, FilterToSQLException { AtomicReference<PreparedFilterToSQL> toSQLref = new AtomicReference<PreparedFilterToSQL>(); String sql = selectSQL(featureType, query, toSQLref); LOGGER.fine(sql); PreparedStatement ps = cx.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); ps.setFetchSize(getDataStore().fetchSize); if (toSQLref.get() != null) { getDataStore().setPreparedFilterValues(ps, toSQLref.get(), 0, cx); } return ps; }