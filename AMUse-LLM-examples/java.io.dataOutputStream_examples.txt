private SnappyCodec(byte[] magic, int version, int compatibleVersion) { this.magic = magic; this.version = version; this.compatibleVersion = compatibleVersion; ByteArrayOutputStream header = new ByteArrayOutputStream(HEADER_SIZE); DataOutputStream d = new DataOutputStream(header); try { d.write(magic, 0, MAGIC_LEN); d.writeInt(version); d.writeInt(compatibleVersion); d.close(); } catch (IOException e) { throw new RuntimeException(e); } headerArray = header.toByteArray(); }
public static void saveBinary(INDArray arr, File saveTo) throws IOException { BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(saveTo)); DataOutputStream dos = new DataOutputStream(bos); Nd4j.write(arr, dos); dos.flush(); dos.close(); bos.close(); }
private static void writeInfoToFile(File file, DiscoverInfo info) throws IOException { DataOutputStream dos = new DataOutputStream(new FileOutputStream(file)); try { dos.writeUTF(info.toXML(null).toString()); } finally { dos.close(); } }
@Override public void close() throws IOException { this.out.flush(); this.out.close(); this.out = null; }
public static void saveFloatArr(DataOutputStream rf, float[] arr) throws IOException { rf.writeInt(arr.length); byte[] lArr = floatArrToByteArr(arr); rf.write(lArr); rf.close(); }
private byte[] getPrelude(int totalLength) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(8); DataOutputStream dos = new DataOutputStream(baos); int headerLength = totalLength - Message.MESSAGE_OVERHEAD - payload.length; dos.writeInt(totalLength); dos.writeInt(headerLength); dos.close(); return baos.toByteArray(); }
private static String createBodyFile(MessageExt msg) throws IOException { DataOutputStream dos = null; try { String bodyTmpFilePath = "/tmp/rocketmq/msgbodys"; File file = new File(bodyTmpFilePath); if (!file.exists()) { file.mkdirs(); } bodyTmpFilePath = bodyTmpFilePath + "/" + msg.getMsgId(); dos = new DataOutputStream(new FileOutputStream(bodyTmpFilePath)); dos.write(msg.getBody()); return bodyTmpFilePath; } finally { if (dos != null) dos.close(); } }
public static String encode(AcidTable table) throws IOException { DataOutputStream data = null; ByteArrayOutputStream bytes = new ByteArrayOutputStream(); try { data = new DataOutputStream(bytes); data.writeUTF(table.getDatabaseName()); data.writeUTF(table.getTableName()); data.writeBoolean(table.createPartitions()); if (table.getWriteId() <= 0) { LOG.warn("Write ID <= 0. The recipient is probably expecting a table write ID."); } data.writeLong(table.getWriteId()); data.writeByte(table.getTableType().getId()); Table metaTable = table.getTable(); if (metaTable != null) { byte[] thrift = new TSerializer(new TCompactProtocol.Factory()).serialize(metaTable); data.writeInt(thrift.length); data.write(thrift); } else { LOG.warn("Meta store table is null. The recipient is probably expecting an instance."); data.writeInt(0); } } catch (TException e) { throw new IOException("Error serializing meta store table.", e); } finally { data.close(); } return PROLOG_V1 + new String(Base64.encodeBase64(bytes.toByteArray()), Charset.forName("UTF-8")); }
DataOutputStream diffOut = new DataOutputStream(byteOut); diffOut.write(MAGIC_BYTES); diffOut.writeLong(-1); diffOut.writeLong(-1); diffOut.writeLong(newsize); diffOut.flush(); DataOutputStream dataOut = new DataOutputStream(bzip2Out); dataOut.writeInt(lenFromOld); dataOut.writeInt((scan - lenb) - (lastscan + lenFromOld)); dataOut.writeInt((pos.value - lenb) - (lastpos + lenFromOld)); dataOut.flush(); bzip2Out.finish(); int ctrlBlockLen = diffOut.size() - BSUtil.HEADER_SIZE; bzip2Out.finish(); bzip2Out.flush(); int diffBlockLen = diffOut.size() - ctrlBlockLen - BSUtil.HEADER_SIZE; diffOut.close(); DataOutputStream headerOut = new DataOutputStream(byteHeaderOut); headerOut.write(MAGIC_BYTES); headerOut.writeLong(ctrlBlockLen); headerOut.writeLong(diffBlockLen);
private static byte[] toBytecode(ClassFile cf) throws IOException { ByteArrayOutputStream barray = new ByteArrayOutputStream(); DataOutputStream out = new DataOutputStream(barray); try { cf.write(out); } finally { out.close(); } return barray.toByteArray(); }
private void outputParam(HttpURLConnection conn, String method, String requestParams, String encoding) throws IOException { if (requestParams != null && !"".equals(requestParams)) { DataOutputStream writer = new DataOutputStream(conn.getOutputStream()); logger.debug("Request out method " + method + ",out parameters " + requestParams); writer.write(requestParams.getBytes(encoding)); writer.flush(); writer.close(); } }
public static void appendToFile( ScriptEngine actualContext, Bindings actualObject, Object[] ArgList, Object FunctionContext ) { if ( !isNull( ArgList ) && !isUndefined( ArgList ) ) { try { FileOutputStream file = new FileOutputStream( (String) ArgList[0], true ); DataOutputStream out = new DataOutputStream( file ); out.writeBytes( (String) ArgList[1] ); out.flush(); out.close(); } catch ( Exception er ) { throw new RuntimeException( er.toString() ); } } else { throw new RuntimeException( "The function call appendToFile requires arguments." ); } }
DataOutputStream out = new DataOutputStream(IOUtil.newOutputStream(path + Predefine.BIN_EXT)); out.writeInt(attributeList.size()); for (Attribute attribute : attributeList) out.writeInt(attribute.p.length); for (int i = 0; i < attribute.p.length; ++i) out.writeInt(charArray.length); for (char c : charArray) out.writeChar(c); out.writeFloat(attribute.p[i]); out.close();
@Deprecated static ByteBuffer toByteBufferV2(TransactionEventRecord record) { ByteArrayOutputStream byteOutput = new ByteArrayOutputStream(512); DataOutputStream dataOutput = new DataOutputStream(byteOutput); try { dataOutput.writeInt(MAGIC_HEADER); dataOutput.writeShort(record.getRecordType()); dataOutput.writeLong(record.getTransactionID()); dataOutput.writeLong(record.getLogWriteOrderID()); record.write(dataOutput); dataOutput.flush(); return ByteBuffer.wrap(byteOutput.toByteArray()); } catch (IOException e) { throw Throwables.propagate(e); } finally { if (dataOutput != null) { try { dataOutput.close(); } catch (IOException e) { LOG.warn("Error closing byte array output stream", e); } } } }
PrimitiveObjectInspector oi) throws IOException { DataOutputStream dos = new DataOutputStream(out); case BOOLEAN: boolean b = ((BooleanObjectInspector) oi).get(o); dos.writeBoolean(b); break; dos.writeByte(bt); break; dos.writeShort(s); break; dos.writeInt(i); break; dos.writeLong(l); break; dos.writeFloat(f); break; dos.writeDouble(d); break; dos.close();
public synchronized List<Sample> getSamples() { if (samples == null) { samples = new ArrayList<>(); long lastEnd = 0; for (Line sub : subs) { long silentTime = sub.from - lastEnd; if (silentTime > 0) { samples.add(new SampleImpl(ByteBuffer.wrap(new byte[]{0, 0}), tx3g)); } else if (silentTime < 0) { throw new Error("Subtitle display times may not intersect"); } ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); try { dos.writeShort(sub.text.getBytes("UTF-8").length); dos.write(sub.text.getBytes("UTF-8")); dos.close(); } catch (IOException e) { throw new Error("VM is broken. Does not support UTF-8"); } samples.add(new SampleImpl(ByteBuffer.wrap(baos.toByteArray()), tx3g)); lastEnd = sub.to; } } return samples; }
public void test(OutputStream output) throws IOException { DataOutputStream out = new DataOutputStream(output); try { out.writeByte(1); out.writeInt(classes.length); for (NClass cls : classes) { writeString(out, cls.getName()); } for (NClass cls : classes) { NClass[] parents = cls.getParents(); out.writeByte(parents.length); for (NClass parent : parents) { out.writeInt(parent.getId()); } } } finally { out.close(); } }
DataOutputStream dos = new DataOutputStream(bos); dos.writeByte(included); Nd4j.write(labelsMask, dos); dos.flush(); dos.close(); } catch (Exception e) { e.printStackTrace();
tmp.deleteOnExit(); dos = new DataOutputStream(new FileOutputStream(tmp)); dos.writeLong(value); dos.flush(); if (dos != null) { try { dos.close(); } catch (IOException e) { throw new RuntimeException(e);
@Override public void writeUTF(String str) throws IOException { final DataOutputStream dos = new DataOutputStream(rf.new RemoteFileOutputStream(fp)); try { dos.writeUTF(str); } finally { dos.close(); } fp += dos.size(); }