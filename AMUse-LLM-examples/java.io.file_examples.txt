String path = "C:" + File.separator + "hello" + File.separator + "hi.txt"; File f = new File(path); f.getParentFile().mkdirs(); f.createNewFile();
File yourFile = new File("score.txt"); yourFile.createNewFile(); FileOutputStream oFile = new FileOutputStream(yourFile, false);
private static boolean createOrExistsFile(final File file) { if (file == null) return false; if (file.exists()) return file.isFile(); if (!createOrExistsDir(file.getParentFile())) return false; try { return file.createNewFile(); } catch (IOException e) { e.printStackTrace(); return false; } }
public static void updateTerm(long term) throws Exception { File file = new File(META_FILE_NAME); if (!file.exists() && !file.getParentFile().mkdirs() && !file.createNewFile()) { throw new IllegalStateException("failed to create meta file"); } try (FileOutputStream outStream = new FileOutputStream(file)) { meta.setProperty("term", String.valueOf(term)); meta.store(outStream, null); } }
public static void main(String[] args) throws IOException { File file = new File("tmp.lock"); file.createNewFile(); FileChannel channel = new RandomAccessFile(file, "r").getChannel(); boolean shared = true; FileLock lock1 = channel.tryLock(0, Long.MAX_VALUE, shared); System.out.println("locked " + lock1); System.in.read(); System.out.println("release " + lock1); lock1.release(); }
public static File createFile(String fileName) throws IOException { File file = null; file = new File(fileName); if (!file.exists()) { file.createNewFile(); } writeToFile(file, getRandomWordSet()); return file; }
public static void copyFile( File from, File to ) throws IOException { if ( !to.exists() ) { to.createNewFile(); } try ( FileChannel in = new FileInputStream( from ).getChannel(); FileChannel out = new FileOutputStream( to ).getChannel() ) { out.transferFrom( in, 0, in.size() ); } }
public static File createFileIfNotExist(File file) { if (!file.exists()) { file.getParentFile().mkdirs(); try { file.createNewFile(); } catch (IOException e) { throw new RuntimeException("create file[" + file.getAbsolutePath() + "] failed!", e); } } return file; }
@CanIgnoreReturnValue private File newFile(String name) throws IOException { File file = new File(rootDir, name); file.createNewFile(); return file; }
private void writeOutEnhancedClass(byte[] enhancedBytecode, File file) { try { if ( file.delete() ) { if ( !file.createNewFile() ) { logger.error( "Unable to recreate class file [" + file.getName() + "]" ); } FileOutputStream outputStream = new FileOutputStream( file, false ); try { outputStream.write( enhancedBytecode ); outputStream.close();
ByteArrayOutputStream bytes = new ByteArrayOutputStream(); _bitmapScaled.compress(Bitmap.CompressFormat.JPEG, 40, bytes); File f = new File(Environment.getExternalStorageDirectory() + File.separator + "test.jpg"); f.createNewFile(); FileOutputStream fo = new FileOutputStream(f); fo.write(bytes.toByteArray()); fo.close();
public static void main(String[] args) throws IOException { String path = getJarLocation(FileUtil.class); System.out.println(path); new File(path, "test.txt").createNewFile(); System.out.println(new File(path).canWrite()); System.out.println(new File(path).getAbsolutePath()); }
public static void createInitializeFile(File dir) throws IOException { File initFile = new File(dir, "initialize"); if (!initFile.exists()) { Assert.assertTrue(initFile.createNewFile()); } }
public static void createFilesByPath(File baseDir, String... files) throws IOException { for (String file : files) { if (file.endsWith("/")) { File file1 = new File(baseDir, file); file1.mkdirs(); } else { File file1 = new File(baseDir, file); file1.getParentFile().mkdirs(); file1.createNewFile(); } } }
void writeInputStream(String filename, InputStream inputStream) throws IOException { File file = new File(TEMP_DIR + filename); file.createNewFile(); try (OutputStream outputStream = new FileOutputStream(file)) { byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = inputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, bytesRead); } } }
public static void writeToFile( File target, String text, boolean append ) throws IOException { if ( !target.exists() ) { Files.createDirectories( target.getParentFile().toPath() ); //noinspection ResultOfMethodCallIgnored target.createNewFile(); } try ( Writer out = new OutputStreamWriter( new FileOutputStream( target, append ), StandardCharsets.UTF_8 ) ) { out.write( text ); } }
public static File createFileIfNotExist(File file) { if (!file.exists()) { file.getParentFile().mkdirs(); try { file.createNewFile(); } catch (IOException e) { throw new RuntimeException("create file[" + file.getAbsolutePath() + "] failed!", e); } } return file; }
@Test public void testWithANonMatchingFile() throws IOException, InterruptedException { watcher.watch(); assertWaitUntil(() -> deploy.get() == 1); File file = new File(root, "foo.nope"); file.createNewFile(); Thread.sleep(500); assertThat(undeploy.get()).isEqualTo(0); assertThat(deploy.get()).isEqualTo(1); }
@Test public void testDelete() throws Exception { assertThat(file.createNewFile()).isTrue(); atomicFile.delete(); assertThat(file.exists()).isFalse(); }
File f = new File(context.getCacheDir(), filename); f.createNewFile(); Bitmap bitmap = your bitmap; ByteArrayOutputStream bos = new ByteArrayOutputStream(); bitmap.compress(CompressFormat.PNG, 0 /*ignored for PNG*/, bos); byte[] bitmapdata = bos.toByteArray(); FileOutputStream fos = new FileOutputStream(f); fos.write(bitmapdata); fos.flush(); fos.close();
File folder = new File(Environment.getExternalStorageDirectory() + "/map"); boolean success = true; if (!folder.exists()) { success = folder.mkdir(); } if (success) { // Do something on success } else { // Do something else on failure }
private static File getSubDirectory(String base, String sub) { File subdir = new File(base, sub); if (!subdir.exists()) { if (!subdir.mkdir()) { throw new IllegalArgumentException("Cannot create subdirectory: " + sub); } } assert subdir.exists() && subdir.isDirectory(); return subdir; }
public static void mkdir(File dir) throws IOException { if (dir.exists()) { if (!dir.isDirectory()) { throw new IOException(MSG_NOT_A_DIRECTORY + dir); } return; } if (!dir.mkdir()) { throw new IOException(MSG_CANT_CREATE + dir); } }
public static File createTemporaryDirectory(String prefix) { final File file = new File(ALLUXIO_TEST_DIRECTORY, prefix + "-" + UUID.randomUUID()); if (!file.mkdir()) { throw new RuntimeException("Failed to create directory " + file.getAbsolutePath()); } Runtime.getRuntime().addShutdownHook(new Thread(() -> delete(file))); return file; }
@BeforeClass public static void setupContent() throws FileNotFoundException { contentFolder.mkdir(); contentFolder.setReadable(true, false); contentFolder.setWritable(true, false); contentFolder.setExecutable(true, false); File indexFile = new File(contentFolder, "index.html"); indexFile.setReadable(true, false); indexFile.setWritable(true, false); indexFile.setExecutable(true, false); @Cleanup PrintStream printStream = new PrintStream(new FileOutputStream(indexFile)); printStream.println("<html><body>This worked</body></html>"); }
boolean createdDir = (new File(distribName)).mkdir(); if(createdDir) { File destFile = new File(filename); String relativePath = distribName + "/" + destFile.getName(); destFile = new File(relativePath); FileSystem.copyFile(new File(filename),destFile);
JobArchiveFetcherTask(List<HistoryServer.RefreshLocation> refreshDirs, File webDir, CountDownLatch numFinishedPolls) { this.refreshDirs = checkNotNull(refreshDirs); this.numFinishedPolls = numFinishedPolls; this.cachedArchives = new HashSet<>(); this.webDir = checkNotNull(webDir); this.webJobDir = new File(webDir, "jobs"); webJobDir.mkdir(); this.webOverviewDir = new File(webDir, "overviews"); webOverviewDir.mkdir(); }
public void initBenchmarkReportDirectory(File benchmarkDirectory) { String timestampString = startingTimestamp.format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HHmmss")); if (StringUtils.isEmpty(name)) { name = timestampString; } if (!benchmarkDirectory.mkdirs()) { if (!benchmarkDirectory.isDirectory()) { throw new IllegalArgumentException("The benchmarkDirectory (" + benchmarkDirectory + ") already exists, but is not a directory."); } if (!benchmarkDirectory.canWrite()) { throw new IllegalArgumentException("The benchmarkDirectory (" + benchmarkDirectory + ") already exists, but is not writable."); } } int duplicationIndex = 0; do { String directoryName = timestampString + (duplicationIndex == 0 ? "" : "_" + duplicationIndex); duplicationIndex++; benchmarkReportDirectory = new File(benchmarkDirectory, BooleanUtils.isFalse(aggregation) ? directoryName : directoryName + "_aggregation"); } while (!benchmarkReportDirectory.mkdir()); for (ProblemBenchmarkResult problemBenchmarkResult : unifiedProblemBenchmarkResultList) { problemBenchmarkResult.makeDirs(); } }
@Before public void setUp() throws Exception { final File testRoot = folder.newFolder(); checkpointDir = new File(testRoot, "checkpoints"); savepointDir = new File(testRoot, "savepoints"); if (!checkpointDir.mkdir() || !savepointDir.mkdirs()) { fail("Test setup failed: failed to create temporary directories."); } }
public static File createTempDirectory() throws IOException { final File temp; temp = File.createTempFile("temp", Long.toString(System.nanoTime())); if(!(temp.delete())) { throw new IOException("Could not delete temp file: " + temp.getAbsolutePath()); } if(!(temp.mkdir())) { throw new IOException("Could not create temp directory: " + temp.getAbsolutePath()); } return (temp); }
private static File createIfDoesNotExist(final String baseDirectoryPath) { final File baseDirectory = new File(baseDirectoryPath); if (!baseDirectory.exists()) { baseDirectory.mkdir(); log.info("Creating dir: " + baseDirectory.getAbsolutePath()); } return baseDirectory; }
private static void makeDir(String path) { File outDir = new File(path); if (!outDir.exists()) { outDir.mkdir(); } }
EmbeddedElasticsearchNode() { try { elasticsearchDirectory = File.createTempFile("elasticsearch", "test"); elasticsearchDirectory.delete(); elasticsearchDirectory.mkdir(); } catch (IOException e) { throw new UncheckedIOException(e); } Settings setting = Settings.builder() .put("cluster.name", "test") .put("path.home", elasticsearchDirectory.getPath()) .put("path.data", new File(elasticsearchDirectory, "data").getAbsolutePath()) .put("path.logs", new File(elasticsearchDirectory, "logs").getAbsolutePath()) .put("transport.type.default", "local") .put("transport.type", "netty4") .put("http.type", "netty4") .put("http.enabled", "true") .put("path.home", "elasticsearch-test-data") .build(); node = new ElasticsearchNode(setting, ImmutableList.of(Netty4Plugin.class)); }
@SuppressWarnings({"Duplicates", "ResultOfMethodCallIgnored"}) @BeforeClass public static void setupContent() throws FileNotFoundException { contentFolder.mkdir(); contentFolder.setReadable(true, false); contentFolder.setWritable(true, false); contentFolder.setExecutable(true, false); File indexFile = new File(contentFolder, "index.html"); indexFile.setReadable(true, false); indexFile.setWritable(true, false); indexFile.setExecutable(true, false); @Cleanup PrintStream printStream = new PrintStream(new FileOutputStream(indexFile)); printStream.println("<html><body>This worked</body></html>"); }
protected void initLaunchDir() { initLaunchId(); try { currentLaunchDir = new File(getConfigurationFile().getParentFile(), getCurrentLaunchId()); if (!currentLaunchDir.mkdir()) { throw new IOException("failed to create directory " + currentLaunchDir); } FileUtils.copyFileToDirectory(getConfigurationFile(), currentLaunchDir); File latestSymlink = new File(getConfigurationFile().getParentFile(), "latest"); latestSymlink.delete(); boolean success = FilesystemLinkMaker.makeSymbolicLink(currentLaunchDir.getName(), latestSymlink.getPath()); if (!success) { LOGGER.warning("failed to create symlink from " + latestSymlink + " to " + currentLaunchDir); } } catch (IOException e) { LOGGER.log(Level.SEVERE, "failed to initialize launch directory: " + e); currentLaunchDir = null; } }
@Override protected AbstractDirectory createDirLocal(String name) throws DirectoryException { File dir = new File(generatePath(name)); dir.mkdir(); return new FileDirectory(dir); }
private void makeSureIsDirectory(File dir) throws IOException { if (!dir.isDirectory()) { boolean success; if (dir.exists()) { success = dir.delete(); if (!success) { throw new IOException("Need to create directory " + dir.getPath() + ", but file exists that cannot be deleted."); } } success = dir.mkdir(); if (!success) { throw new IOException("Cannot create directory " + dir.getPath()); } } }
public static File createTempDirectory() throws BrutException { try { File tmp = File.createTempFile("BRUT", null); tmp.deleteOnExit(); if (!tmp.delete()) { throw new BrutException("Could not delete tmp file: " + tmp.getAbsolutePath()); } if (!tmp.mkdir()) { throw new BrutException("Could not create tmp dir: " + tmp.getAbsolutePath()); } return tmp; } catch (IOException ex) { throw new BrutException("Could not create tmp dir", ex); } }
private void makeArtifactoryCache(String location) throws IOException { String localDirName = ServerConfigUtils.masterLocalDir(conf) + File.separator + LOCAL_ARTIFACT_DIR; File dir = new File(localDirName); if (!dir.exists()) { dir.mkdirs(); } localCacheDir = localDirName + File.separator + location.replaceAll(File.separator, "_"); dir = new File(localCacheDir); if (!dir.exists()) { dir.mkdir(); } cacheInitialized = true; }
File theDir = new File("new folder"); if (!theDir.exists()) { System.out.println("creating directory: " + directoryName); boolean result = false; try{ theDir.mkdir(); result = true; } catch(SecurityException se){ } if(result) { System.out.println("DIR created"); } }