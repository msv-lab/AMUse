public static String[] split(String separators, String list, boolean include) { StringTokenizer tokens = new StringTokenizer( list, separators, include ); String[] result = new String[tokens.countTokens()]; int i = 0; while ( tokens.hasMoreTokens() ) { result[i++] = tokens.nextToken(); } return result; }
public static ArrayList<String> tokenize(String line) { ArrayList<String> tokens = new ArrayList<>(); StringTokenizer tokenizer = new StringTokenizer(line); while (tokenizer.hasMoreElements()) { tokens.add(tokenizer.nextToken()); } return tokens; }
StringTokenizer tokens = new StringTokenizer(CurrentString, ":"); String first = tokens.nextToken(); String second = tokens.nextToken();
public void setListeners(String listeners) { StringTokenizer st= new StringTokenizer(listeners, " ,"); while(st.hasMoreTokens()) { m_listeners.add(st.nextToken()); } }
protected void loadMapping(InputStream inputStream) throws IOException { InputStreamReader isr = new InputStreamReader(inputStream); BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) { StringTokenizer st = new StringTokenizer(line); if (st.countTokens() != 2) { throw new IOException("Wrong file format"); } mapping.put(st.nextToken(), st.nextToken()); } br.close(); isr.close(); inputStream.close(); } }
BufferedReader hin = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(buf, 0, rlen))); Map<String, String> pre = new HashMap<String, String>(); InputStream bin = new FileInputStream(f.getFD()); BufferedReader in = new BufferedReader(new InputStreamReader(bin)); st = new StringTokenizer(contentTypeHeader, ",; "); if (st.hasMoreTokens()) { contentType = st.nextToken(); if (!st.hasMoreTokens()) { Response.error(outputStream, int read = in.read(pbuf); while (read >= 0 && !postLine.endsWith("\r\n"))) { postLine += String.valueOf(pbuf, 0, read); }
cellhead = new BufferedReader(new FileReader(cellhd)); cellhead.mark(128); if ((line = cellhead.readLine()) == null) { throw new IOException("The cellhead file seems to be corrupted: " + cellhd.getAbsolutePath() + cellhd.getAbsolutePath()); cellhead = new BufferedReader(new FileReader(cellhd)); } else { new FileReader(readerGrassEnv.getCELLMISC_FORMAT())); while ((line = cellmiscformat.readLine()) != null) { StringTokenizer tokk = new StringTokenizer(line, ":"); if (tokk.countTokens() == 2) { String key = tokk.nextToken().trim(); String value = tokk.nextToken().trim(); readerFileHeaderMap.put(key, value); }
@Override @Nullable public String[] getParameterNames(Method method) { if (method.getParameterCount() == 0) { return new String[0]; } AspectJAnnotation<?> annotation = findAspectJAnnotationOnMethod(method); if (annotation == null) { return null; } StringTokenizer nameTokens = new StringTokenizer(annotation.getArgumentNames(), ","); if (nameTokens.countTokens() > 0) { String[] names = new String[nameTokens.countTokens()]; for (int i = 0; i < names.length; i++) { names[i] = nameTokens.nextToken(); } return names; } else { return null; } }
public void setProperties(String props) { Map hashTable = new HashMap(); StringTokenizer pairs = new StringTokenizer(props, ","); while (pairs.hasMoreTokens()) { StringTokenizer entry = new StringTokenizer(pairs.nextToken(), "="); hashTable.put(entry.nextElement().toString().trim(), entry.nextElement().toString().trim()); } synchronized(this) { properties = hashTable; } }
public String[] getDropStrings(String str, String sep) { StringTokenizer strtok = new StringTokenizer(str, sep); String[] retval = new String[strtok.countTokens()]; int i = 0; while (strtok.hasMoreElements()) { retval[i] = strtok.nextToken(); i++; } return retval; }
int stringTokenizer = new StringTokenizer(" " +testString + " ", ".").countTokens()-1; System.out.println("stringTokenizer = " + stringTokenizer);
Rule(StringTokenizer st) { if (st.countTokens() < 6) { throw new IllegalArgumentException("Attempting to create a Rule from an incomplete tokenizer"); } iName = st.nextToken().intern(); iFromYear = parseYear(st.nextToken(), 0); iToYear = parseYear(st.nextToken(), iFromYear); if (iToYear < iFromYear) { throw new IllegalArgumentException(); } iType = parseOptional(st.nextToken()); iDateTimeOfYear = new DateTimeOfYear(st); iSaveMillis = parseTime(st.nextToken()); iLetterS = parseOptional(st.nextToken()); }
public static String deblank(String str) { StringTokenizer s = new StringTokenizer(str, " ", false); StringBuilder strRet = new StringBuilder(); while (s.hasMoreElements()) strRet.append(s.nextElement()); return strRet.toString(); }
public Object nextElement() { return nextToken(); }
public boolean hasMoreElements() { return hasMoreTokens(); }
private static Profiles parseExpression(String expression) { Assert.hasText(expression, () -> "Invalid profile expression [" + expression + "]: must contain text"); StringTokenizer tokens = new StringTokenizer(expression, "()&|!", true); return parseTokens(expression, tokens); }
public void setMethodSelectors(String methodSelectors) { StringTokenizer st= new StringTokenizer(methodSelectors, " ,"); while(st.hasMoreTokens()) { m_methodselectors.add(st.nextToken()); } }
private double[] parseDoubleArray(String value, String key) { try { StringTokenizer tokenizer = new StringTokenizer(value); double[] result = new double[tokenizer.countTokens()]; for (int i = 0; i < result.length; i++) { result[i] = new Double(tokenizer.nextToken()).doubleValue(); } return result; } catch (NumberFormatException e) { throw createNumberFormatException("sequence of numbers", value, key); } }
public static void reset() { String s = "UK 123"; StringTokenizer st = new StringTokenizer(s); property = st.nextToken(); } }
@Benchmark public int stringTokenizer() { return new StringTokenizer(" " + testString + " ", ".").countTokens() - 1; }