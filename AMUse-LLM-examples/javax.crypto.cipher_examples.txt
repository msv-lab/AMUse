private static Cipher toCipher(RSAKey key, int mode) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance("RSA"); cipher.init(mode, (Key)key); return cipher; }
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv)); String plaintext = new String(cipher.doFinal(ciphertext), "UTF-8"); System.out.println(plaintext);
public static Cipher initDecryptionCipher( Key unwrappedKey, byte[] unencryptedKey ) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException { Cipher decryptionCip = Cipher.getInstance( SINGLE_KEY_ALGORITHM ); if ( unwrappedKey != null ) { decryptionCip.init( Cipher.ENCRYPT_MODE, unwrappedKey ); } else { SecretKeySpec sks = new SecretKeySpec( unencryptedKey, SINGLE_KEY_ALGORITHM ); decryptionCip.init( Cipher.ENCRYPT_MODE, sks ); } return decryptionCip; }
private byte[] aes(byte[] data, byte[] key, byte[] iv, int mode) throws Exception { Cipher cipher = Cipher.getInstance(AES_MODE); cipher.init(mode, new SecretKeySpec(key, "AES"), new IvParameterSpec(iv)); return cipher.doFinal(data); }
public static String decryptByPrivateKey(String data, RSAPrivateKey privateKey) throws Exception { Cipher cipher = Cipher.getInstance("RSA/ECB/NoPadding"); cipher.init(Cipher.DECRYPT_MODE, privateKey); int key_len = privateKey.getModulus().bitLength() / 8; byte[] bytes = data.getBytes(); byte[] bcd = ASCII_To_BCD(bytes, bytes.length); System.err.println(bcd.length); String ming = ""; byte[][] arrays = splitArray(bcd, key_len); for (byte[] arr : arrays) { ming += new String(cipher.doFinal(arr)); } return ming; }
skf = SecretKeyFactory.getInstance(myEncryptionScheme); cipher = Cipher.getInstance(myEncryptionScheme); key = skf.generateSecret(ks); String encryptedString = null; try { cipher.init(Cipher.ENCRYPT_MODE, key); byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT); byte[] encryptedText = cipher.doFinal(plainText); encryptedString = new String(Base64.encodeBase64(encryptedText)); } catch (Exception e) { String decryptedText=null; try { cipher.init(Cipher.DECRYPT_MODE, key); byte[] encryptedText = Base64.decodeBase64(encryptedString); byte[] plainText = cipher.doFinal(encryptedText); decryptedText= new String(plainText); } catch (Exception e) { String decrypted=td.decrypt(encrypted); System.out.println("String To Encrypt: "+ target); System.out.println("Encrypted String:" + encrypted); System.out.println("Decrypted String:" + decrypted);
private static PKCS8EncodedKeySpec createKeySpec(byte[] keyBytes, String password) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException { if (Strings.isNullOrEmpty(password)) { return new PKCS8EncodedKeySpec(keyBytes); } final EncryptedPrivateKeyInfo pkInfo = new EncryptedPrivateKeyInfo(keyBytes); final SecretKeyFactory kf = SecretKeyFactory.getInstance(pkInfo.getAlgName()); final PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); final SecretKey secretKey = kf.generateSecret(keySpec); @SuppressWarnings("InsecureCryptoUsage") final Cipher cipher = Cipher.getInstance(pkInfo.getAlgName()); cipher.init(Cipher.DECRYPT_MODE, secretKey, pkInfo.getAlgParameters()); return pkInfo.getKeySpec(cipher); }
public static String encryptUsingAES(SecretKey secretKey, String dataToEncrypt) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException { Cipher aesCipher = Cipher.getInstance("AES"); aesCipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] byteCipherText = aesCipher.doFinal(dataToEncrypt.getBytes()); return Base64.getEncoder().encodeToString(byteCipherText); }
private String encrypt(String property) throws GeneralSecurityException, UnsupportedEncodingException { SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBEWithMD5AndDES"); SecretKey key = keyFactory.generateSecret(new PBEKeySpec(habridgeKey)); Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES"); pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(SALT, 20)); return base64Encode(pbeCipher.doFinal(property.getBytes("UTF-8"))); }
public CombinedCipherOutputStream(OutputStream out, Cipher asym, String algorithm) throws IOException, GeneralSecurityException { super(out); String keyAlgorithm = getKeyAlgorithm(algorithm); SecretKey symKey = KeyGenerator.getInstance(keyAlgorithm).generateKey(); out.write(asym.doFinal(symKey.getEncoded())); Cipher sym = Secret.getCipher(algorithm); sym.init(Cipher.ENCRYPT_MODE,symKey, keyAlgorithm.equals(algorithm) ? null : new IvParameterSpec(symKey.getEncoded())); super.out = new CipherOutputStream(out,sym); }
private void decodeSessionKey(byte[] encodedKey) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException { Cipher sessionKeyCipher = RSA_CIPHER.get(); sessionKeyCipher.init(Cipher.DECRYPT_MODE, privateKey); byte[] sessionKeyBytes = sessionKeyCipher.doFinal(encodedKey); sessionKey = new SecretKeySpec(sessionKeyBytes, 0, SESSION_KEY_SIZE / 8, SESSION_KEY_ALGORITHM); }
@Override public void init(byte[] key, byte[] iv) throws IOException { Preconditions.checkNotNull(key); Preconditions.checkNotNull(iv); contextReset = false; try { cipher.init(mode, new SecretKeySpec(key, "AES"), new IvParameterSpec(iv)); } catch (Exception e) { throw new IOException(e); } }
public Connection encryptConnection(SecretKey sessionKey, String algorithm) throws IOException, GeneralSecurityException { Cipher cout = Cipher.getInstance(algorithm); cout.init(Cipher.ENCRYPT_MODE, sessionKey, new IvParameterSpec(sessionKey.getEncoded())); CipherOutputStream o = new CipherOutputStream(out, cout); Cipher cin = Cipher.getInstance(algorithm); cin.init(Cipher.DECRYPT_MODE, sessionKey, new IvParameterSpec(sessionKey.getEncoded())); CipherInputStream i = new CipherInputStream(in, cin); return new Connection(i,o); }
public static String protect(String secret) { try { Cipher cipher = Secret.getCipher(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, DES_KEY); return new String(Base64.encode(cipher.doFinal((secret+ MAGIC).getBytes("UTF-8")))); } catch (GeneralSecurityException e) { throw new Error(e); } catch (UnsupportedEncodingException e) { throw new Error(e); } }
PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory keyFac = SecretKeyFactory.getInstance(MYPBEALG); SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec); pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec); byte[] ciphertext = pbeCipher.doFinal(encodedprivkey);
@Restricted(NoExternalUse.class) public Cipher encrypt(byte[] iv) { try { Cipher cipher = Secret.getCipher(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, getKey(), new IvParameterSpec(iv)); return cipher; } catch (GeneralSecurityException e) { throw new AssertionError(e); } }
@Nullable public static String encrypt(String plainText, String encryptionKey, String salt) { try { @SuppressWarnings("CIPHER_INTEGRITY") Cipher cipher = Cipher.getInstance("AES/CBC/ISO10126Padding", "SunJCE"); SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes("UTF-8"), "AES"); cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(salt.getBytes("UTF-8"))); return Hex.encodeToString(cipher.doFinal(plainText.getBytes("UTF-8"))); } catch (Exception e) { LOG.error("Could not encrypt value.", e); } return null; }
byte[] expBytes = Base64.decodeBase64(exponentElem.getText().trim())); byte[] modBytes = Base64.decodeBase64(modulusElem.getText().trim()); byte[] dBytes = Base64.decodeBase64(dElem.getText().trim()); BigInteger modules = new BigInteger(1, modBytes); BigInteger exponent = new BigInteger(1, expBytes); BigInteger d = new BigInteger(1, dBytes); KeyFactory factory = KeyFactory.getInstance("RSA"); Cipher cipher = Cipher.getInstance("RSA"); String input = "test"; RSAPublicKeySpec pubSpec = new RSAPublicKeySpec(modules, exponent); PublicKey pubKey = factory.generatePublic(pubSpec); cipher.init(Cipher.ENCRYPT_MODE, pubKey); byte[] encrypted = cipher.doFinal(input.getBytes("UTF-8")); System.out.println("encrypted: " + new String(encrypted)); RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(modules, d); PrivateKey privKey = factory.generatePrivate(privSpec); cipher.init(Cipher.DECRYPT_MODE, privKey); byte[] decrypted = cipher.doFinal(encrypted); System.out.println("decrypted: " + new String(decrypted));
public static Cipher initPBECipher(String algorithm, String provider, String password, byte[] salt, int iterationCount, boolean encryptMode) throws IllegalArgumentException { try { final PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray()); final SecretKeyFactory factory = SecretKeyFactory.getInstance(algorithm, provider); SecretKey tempKey = factory.generateSecret(pbeKeySpec); final PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, iterationCount); Cipher cipher = Cipher.getInstance(algorithm, provider); cipher.init(encryptMode ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, tempKey, parameterSpec); return cipher; } catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeySpecException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException e) { throw new IllegalArgumentException("One or more parameters to initialize the PBE cipher were invalid", e); } }
public static String decryptUsingAES(SecretKey secretKey, String dataToDecrypt) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException { Cipher aesCipher = Cipher.getInstance("AES"); aesCipher.init(Cipher.DECRYPT_MODE, secretKey); byte[] bytePlainText = aesCipher.doFinal(Base64.getDecoder().decode(dataToDecrypt)); return new String(bytePlainText); }