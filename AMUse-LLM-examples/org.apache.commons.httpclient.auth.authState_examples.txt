public void setAuthScheme(final AuthScheme authScheme) { if (authScheme == null) { invalidate(); return; } if (this.preemptive && !(this.authScheme.getClass().isInstance(authScheme))) { this.preemptive = false; this.authAttempted = false; } this.authScheme = authScheme; }
AuthScheme authscheme = authstate.getAuthScheme(); if (authscheme == null) { return; if (authstate.isAuthRequested() || !authscheme.isConnectionBased()) { AuthScope authscope = new AuthScope( conn.getProxyHost(), conn.getProxyPort(), if (LOG.isWarnEnabled()) { LOG.warn("Required proxy credentials not available for " + authscope); if (method.getProxyAuthState().isPreemptive()) { LOG.warn("Preemptive authentication requested but no default " + "proxy credentials available");
LOG.debug("Proxy authentication scope: " + authscope); if (authstate.isAuthAttempted() && authscheme.isComplete()) { authstate.setAuthAttempted(true); Credentials credentials = this.state.getProxyCredentials(authscope); if (credentials == null) {
if (state.isPreemptive() || state.getAuthScheme() == null) { state.setAuthScheme(selectAuthScheme(challenges)); AuthScheme authscheme = state.getAuthScheme(); String id = authscheme.getSchemeName(); if (LOG.isDebugEnabled()) {
private boolean isAuthenticationNeeded(final HttpMethod method) { method.getHostAuthState().setAuthRequested( method.getStatusCode() == HttpStatus.SC_UNAUTHORIZED); method.getProxyAuthState().setAuthRequested( method.getStatusCode() == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED); if (method.getHostAuthState().isAuthRequested() || method.getProxyAuthState().isAuthRequested()) { LOG.debug("Authorization required"); if (method.getDoAuthentication()) { return true; } else { LOG.info("Authentication requested but doAuthentication is " + "disabled"); return false; } } else { return false; } }
this.connectMethod.getResponseBodyAsStream()); method.getProxyAuthState().setAuthScheme(this.connectMethod.getProxyAuthState().getAuthScheme()); this.connectMethod = null; } else {
|| this.state.isAuthenticationPreemptive()) { LOG.debug("Preemptively sending default basic credentials"); this.connectMethod.getProxyAuthState().setPreemptive(); this.connectMethod.getProxyAuthState().setAuthAttempted(true); boolean retry = false; AuthState authstate = this.connectMethod.getProxyAuthState(); authstate.setAuthRequested(code == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED); if (authstate.isAuthRequested()) { if (processAuthenticationResponse(this.connectMethod)) { retry = true; 
method.getHostAuthState().setPreemptive(); method.getHostAuthState().setAuthAttempted(true); if (this.conn.isProxied() && !this.conn.isSecure()) { method.getProxyAuthState().setPreemptive(); method.getProxyAuthState().setAuthAttempted(true);
public String getProxyAuthenticationRealm() { return this.proxyAuthState.getRealm(); }
public void processRequest(HttpMethod method) { DigestScheme scheme = digestScheme; if (scheme != null) { if (DEBUG_AUTH) { System.err.println(location.getUrl() + ": Digest scheme is present"); //$NON-NLS-1$ } Credentials creds = httpClient.getState().getCredentials(authScope); if (creds != null) { if (DEBUG_AUTH) { System.err.println(location.getUrl() + ": Setting digest scheme for request"); //$NON-NLS-1$ } method.getHostAuthState().setAuthScheme(digestScheme); method.getHostAuthState().setAuthRequested(true); } } }
@SuppressWarnings("null") public void processResponse(HttpMethod method) throws XmlRpcException { if (isContentTypeCheckingEnabled()) { Header contentTypeHeader = method.getResponseHeader("Content-Type"); //$NON-NLS-1$ if (contentTypeHeader == null || !DEFAULT_CONTENT_TYPE.equals(contentTypeHeader.getValue())) { throw new XmlRpcIllegalContentTypeException( NLS.bind( "The server returned an unexpected content type: ''{0}''", contentTypeHeader.getValue()), contentTypeHeader.getValue()); //$NON-NLS-1$ } } AuthScheme authScheme = method.getHostAuthState().getAuthScheme(); if (authScheme instanceof DigestScheme) { digestScheme = (DigestScheme) authScheme; if (DEBUG_AUTH) { System.err.println(location.getUrl() + ": Received digest scheme"); //$NON-NLS-1$ } } }
private void addHeaders(HttpMethod httpMethod) { httpMethod.setDoAuthentication(true); httpMethod.addRequestHeader("User-Agent", "Atlassian Tomcat API"); httpMethod.getHostAuthState().isPreemptive(); }
if(retryCount == 0 && authstate.isAuthAttempted() && authscheme.isComplete()) { return null;
if (httpMethod.getHostAuthState().isAuthRequested() && retryCount++ < 1 && doRequestedAuthentication( httpClient, httpMethod, request, response))
|| this.state.isAuthenticationPreemptive()) { LOG.debug("Preemptively sending default basic credentials"); this.connectMethod.getProxyAuthState().setPreemptive(); this.connectMethod.getProxyAuthState().setAuthAttempted(true); boolean retry = false; AuthState authstate = this.connectMethod.getProxyAuthState(); authstate.setAuthRequested(code == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED); if (authstate.isAuthRequested()) { if (processAuthenticationResponse(this.connectMethod)) { retry = true;
if (state.isPreemptive() || state.getAuthScheme() == null) { state.setAuthScheme(selectAuthScheme(challenges)); AuthScheme authscheme = state.getAuthScheme(); String id = authscheme.getSchemeName(); if (LOG.isDebugEnabled()) {
private boolean isAuthenticationNeeded(final HttpMethod method) { method.getHostAuthState().setAuthRequested(method.getStatusCode() == HttpStatus.SC_UNAUTHORIZED); method.getProxyAuthState().setAuthRequested(method.getStatusCode() == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED); if (method.getHostAuthState().isAuthRequested() || method.getProxyAuthState().isAuthRequested()) { LOG.debug("Authorization required"); if (method.getDoAuthentication()) { return true; } else { LOG.info("Authentication requested but doAuthentication is " + "disabled"); return false; } } else { return false; }}
this.connectMethod.getResponseBodyAsStream()); method.getProxyAuthState().setAuthScheme(this.connectMethod.getProxyAuthState().getAuthScheme()); this.connectMethod = null; } else {
method.getHostAuthState().setPreemptive(); method.getHostAuthState().setAuthAttempted(true); if (this.conn.isProxied() && !this.conn.isSecure()) { method.getProxyAuthState().setPreemptive(); method.getProxyAuthState().setAuthAttempted(true);
public String getAuthenticationRealm() { return this.hostAuthState.getRealm(); }